// Generated by gir (https://github.com/gtk-rs/gir @ e8f82cf)
// from ../gir-files (@ 6f12897)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(
	clippy::approx_constant,
	clippy::type_complexity,
	clippy::unreadable_literal,
	clippy::upper_case_acronyms
)]
#![cfg_attr(feature = "dox", feature(doc_cfg))]

use gio_sys as gio;
use glib_sys as glib;
use gobject_sys as gobject;

#[allow(unused_imports)]
use libc::{
	c_char, c_double, c_float, c_int, c_long, c_short, c_uchar, c_uint, c_ulong, c_ushort, c_void,
	intptr_t, size_t, ssize_t, time_t, uintptr_t, FILE,
};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Aliases
pub type ArvPixelFormat = u32;

// Enums
pub type ArvAcquisitionMode = c_int;
pub const ARV_ACQUISITION_MODE_CONTINUOUS: ArvAcquisitionMode = 0;
pub const ARV_ACQUISITION_MODE_SINGLE_FRAME: ArvAcquisitionMode = 1;
pub const ARV_ACQUISITION_MODE_MULTI_FRAME: ArvAcquisitionMode = 2;

pub type ArvAuto = c_int;
pub const ARV_AUTO_OFF: ArvAuto = 0;
pub const ARV_AUTO_ONCE: ArvAuto = 1;
pub const ARV_AUTO_CONTINUOUS: ArvAuto = 2;

pub type ArvBufferPayloadType = c_int;
pub const ARV_BUFFER_PAYLOAD_TYPE_UNKNOWN: ArvBufferPayloadType = -1;
pub const ARV_BUFFER_PAYLOAD_TYPE_IMAGE: ArvBufferPayloadType = 1;
pub const ARV_BUFFER_PAYLOAD_TYPE_RAWDATA: ArvBufferPayloadType = 2;
pub const ARV_BUFFER_PAYLOAD_TYPE_FILE: ArvBufferPayloadType = 3;
pub const ARV_BUFFER_PAYLOAD_TYPE_CHUNK_DATA: ArvBufferPayloadType = 4;
pub const ARV_BUFFER_PAYLOAD_TYPE_EXTENDED_CHUNK_DATA: ArvBufferPayloadType = 5;
pub const ARV_BUFFER_PAYLOAD_TYPE_JPEG: ArvBufferPayloadType = 6;
pub const ARV_BUFFER_PAYLOAD_TYPE_JPEG2000: ArvBufferPayloadType = 7;
pub const ARV_BUFFER_PAYLOAD_TYPE_H264: ArvBufferPayloadType = 8;
pub const ARV_BUFFER_PAYLOAD_TYPE_MULTIZONE_IMAGE: ArvBufferPayloadType = 9;
pub const ARV_BUFFER_PAYLOAD_TYPE_IMAGE_EXTENDED_CHUNK: ArvBufferPayloadType = 16385;

pub type ArvBufferStatus = c_int;
pub const ARV_BUFFER_STATUS_UNKNOWN: ArvBufferStatus = -1;
pub const ARV_BUFFER_STATUS_SUCCESS: ArvBufferStatus = 0;
pub const ARV_BUFFER_STATUS_CLEARED: ArvBufferStatus = 1;
pub const ARV_BUFFER_STATUS_TIMEOUT: ArvBufferStatus = 2;
pub const ARV_BUFFER_STATUS_MISSING_PACKETS: ArvBufferStatus = 3;
pub const ARV_BUFFER_STATUS_WRONG_PACKET_ID: ArvBufferStatus = 4;
pub const ARV_BUFFER_STATUS_SIZE_MISMATCH: ArvBufferStatus = 5;
pub const ARV_BUFFER_STATUS_FILLING: ArvBufferStatus = 6;
pub const ARV_BUFFER_STATUS_ABORTED: ArvBufferStatus = 7;

pub type ArvChunkParserError = c_int;
pub const ARV_CHUNK_PARSER_ERROR_INVALID_FEATURE_TYPE: ArvChunkParserError = 0;
pub const ARV_CHUNK_PARSER_ERROR_BUFFER_NOT_FOUND: ArvChunkParserError = 1;
pub const ARV_CHUNK_PARSER_ERROR_CHUNK_NOT_FOUND: ArvChunkParserError = 2;

pub type ArvDeviceError = c_int;
pub const ARV_DEVICE_ERROR_WRONG_FEATURE: ArvDeviceError = 0;
pub const ARV_DEVICE_ERROR_FEATURE_NOT_FOUND: ArvDeviceError = 1;
pub const ARV_DEVICE_ERROR_NOT_CONNECTED: ArvDeviceError = 2;
pub const ARV_DEVICE_ERROR_PROTOCOL_ERROR: ArvDeviceError = 3;
pub const ARV_DEVICE_ERROR_TRANSFER_ERROR: ArvDeviceError = 4;
pub const ARV_DEVICE_ERROR_TIMEOUT: ArvDeviceError = 5;
pub const ARV_DEVICE_ERROR_NOT_FOUND: ArvDeviceError = 6;
pub const ARV_DEVICE_ERROR_INVALID_PARAMETER: ArvDeviceError = 7;
pub const ARV_DEVICE_ERROR_GENICAM_NOT_FOUND: ArvDeviceError = 8;
pub const ARV_DEVICE_ERROR_NO_STREAM_CHANNEL: ArvDeviceError = 9;
pub const ARV_DEVICE_ERROR_NOT_CONTROLLER: ArvDeviceError = 10;
pub const ARV_DEVICE_ERROR_UNKNOWN: ArvDeviceError = 11;

pub type ArvDomNodeType = c_int;
pub const ARV_DOM_NODE_TYPE_ELEMENT_NODE: ArvDomNodeType = 1;
pub const ARV_DOM_NODE_TYPE_ATTRIBUTE_NODE: ArvDomNodeType = 2;
pub const ARV_DOM_NODE_TYPE_TEXT_NODE: ArvDomNodeType = 3;
pub const ARV_DOM_NODE_TYPE_CDATA_SECTION_NODE: ArvDomNodeType = 4;
pub const ARV_DOM_NODE_TYPE_ENTITY_REFERENCE_NODE: ArvDomNodeType = 5;
pub const ARV_DOM_NODE_TYPE_ENTITY_NODE: ArvDomNodeType = 6;
pub const ARV_DOM_NODE_TYPE_PROCESSING_INSTRUCTION_NODE: ArvDomNodeType = 7;
pub const ARV_DOM_NODE_TYPE_COMMENT_NODE: ArvDomNodeType = 8;
pub const ARV_DOM_NODE_TYPE_DOCUMENT_NODE: ArvDomNodeType = 9;
pub const ARV_DOM_NODE_TYPE_DOCUMENT_TYPE_NODE: ArvDomNodeType = 10;
pub const ARV_DOM_NODE_TYPE_DOCUMENT_FRAGMENT_NODE: ArvDomNodeType = 11;
pub const ARV_DOM_NODE_TYPE_NOTATION_NODE: ArvDomNodeType = 12;

pub type ArvExposureMode = c_int;
pub const ARV_EXPOSURE_MODE_OFF: ArvExposureMode = 0;
pub const ARV_EXPOSURE_MODE_TIMED: ArvExposureMode = 1;
pub const ARV_EXPOSURE_MODE_TRIGGER_WIDTH: ArvExposureMode = 2;
pub const ARV_EXPOSURE_MODE_TRIGGER_CONTROLLED: ArvExposureMode = 3;

pub type ArvGcAccessMode = c_int;
pub const ARV_GC_ACCESS_MODE_UNDEFINED: ArvGcAccessMode = -1;
pub const ARV_GC_ACCESS_MODE_RO: ArvGcAccessMode = 0;
pub const ARV_GC_ACCESS_MODE_WO: ArvGcAccessMode = 1;
pub const ARV_GC_ACCESS_MODE_RW: ArvGcAccessMode = 2;

pub type ArvGcCachable = c_int;
pub const ARV_GC_CACHABLE_UNDEFINED: ArvGcCachable = -1;
pub const ARV_GC_CACHABLE_NO_CACHE: ArvGcCachable = 0;
pub const ARV_GC_CACHABLE_WRITE_THROUGH: ArvGcCachable = 1;
pub const ARV_GC_CACHABLE_WRITE_AROUND: ArvGcCachable = 2;

pub type ArvGcDisplayNotation = c_int;
pub const ARV_GC_DISPLAY_NOTATION_UNDEFINED: ArvGcDisplayNotation = -1;
pub const ARV_GC_DISPLAY_NOTATION_AUTOMATIC: ArvGcDisplayNotation = 0;
pub const ARV_GC_DISPLAY_NOTATION_FIXED: ArvGcDisplayNotation = 1;
pub const ARV_GC_DISPLAY_NOTATION_SCIENTIFIC: ArvGcDisplayNotation = 2;

pub type ArvGcError = c_int;
pub const ARV_GC_ERROR_PROPERTY_NOT_DEFINED: ArvGcError = 0;
pub const ARV_GC_ERROR_PVALUE_NOT_DEFINED: ArvGcError = 1;
pub const ARV_GC_ERROR_INVALID_PVALUE: ArvGcError = 2;
pub const ARV_GC_ERROR_EMPTY_ENUMERATION: ArvGcError = 3;
pub const ARV_GC_ERROR_OUT_OF_RANGE: ArvGcError = 4;
pub const ARV_GC_ERROR_NO_DEVICE_SET: ArvGcError = 5;
pub const ARV_GC_ERROR_NO_EVENT_IMPLEMENTATION: ArvGcError = 6;
pub const ARV_GC_ERROR_NODE_NOT_FOUND: ArvGcError = 7;
pub const ARV_GC_ERROR_ENUM_ENTRY_NOT_FOUND: ArvGcError = 8;
pub const ARV_GC_ERROR_INVALID_LENGTH: ArvGcError = 9;
pub const ARV_GC_ERROR_READ_ONLY: ArvGcError = 10;
pub const ARV_GC_ERROR_SET_FROM_STRING_UNDEFINED: ArvGcError = 11;
pub const ARV_GC_ERROR_GET_AS_STRING_UNDEFINED: ArvGcError = 12;
pub const ARV_GC_ERROR_INVALID_BIT_RANGE: ArvGcError = 13;

pub type ArvGcIsLinear = c_int;
pub const ARV_GC_IS_LINEAR_UNDEFINED: ArvGcIsLinear = -1;
pub const ARV_GC_IS_LINEAR_NO: ArvGcIsLinear = 0;
pub const ARV_GC_IS_LINEAR_YES: ArvGcIsLinear = 1;

pub type ArvGcNameSpace = c_int;
pub const ARV_GC_NAME_SPACE_UNDEFINED: ArvGcNameSpace = -1;
pub const ARV_GC_NAME_SPACE_STANDARD: ArvGcNameSpace = 0;
pub const ARV_GC_NAME_SPACE_CUSTOM: ArvGcNameSpace = 1;

pub type ArvGcPropertyNodeType = c_int;
pub const ARV_GC_PROPERTY_NODE_TYPE_UNKNOWN: ArvGcPropertyNodeType = 0;
pub const ARV_GC_PROPERTY_NODE_TYPE_VALUE: ArvGcPropertyNodeType = 1;
pub const ARV_GC_PROPERTY_NODE_TYPE_ADDRESS: ArvGcPropertyNodeType = 2;
pub const ARV_GC_PROPERTY_NODE_TYPE_DESCRIPTION: ArvGcPropertyNodeType = 3;
pub const ARV_GC_PROPERTY_NODE_TYPE_VISIBILITY: ArvGcPropertyNodeType = 4;
pub const ARV_GC_PROPERTY_NODE_TYPE_TOOLTIP: ArvGcPropertyNodeType = 5;
pub const ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NAME: ArvGcPropertyNodeType = 6;
pub const ARV_GC_PROPERTY_NODE_TYPE_MINIMUM: ArvGcPropertyNodeType = 7;
pub const ARV_GC_PROPERTY_NODE_TYPE_MAXIMUM: ArvGcPropertyNodeType = 8;
pub const ARV_GC_PROPERTY_NODE_TYPE_SLOPE: ArvGcPropertyNodeType = 9;
pub const ARV_GC_PROPERTY_NODE_TYPE_INCREMENT: ArvGcPropertyNodeType = 10;
pub const ARV_GC_PROPERTY_NODE_TYPE_IS_LINEAR: ArvGcPropertyNodeType = 11;
pub const ARV_GC_PROPERTY_NODE_TYPE_REPRESENTATION: ArvGcPropertyNodeType = 12;
pub const ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NOTATION: ArvGcPropertyNodeType = 13;
pub const ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_PRECISION: ArvGcPropertyNodeType = 14;
pub const ARV_GC_PROPERTY_NODE_TYPE_UNIT: ArvGcPropertyNodeType = 15;
pub const ARV_GC_PROPERTY_NODE_TYPE_ON_VALUE: ArvGcPropertyNodeType = 16;
pub const ARV_GC_PROPERTY_NODE_TYPE_OFF_VALUE: ArvGcPropertyNodeType = 17;
pub const ARV_GC_PROPERTY_NODE_TYPE_LENGTH: ArvGcPropertyNodeType = 18;
pub const ARV_GC_PROPERTY_NODE_TYPE_FORMULA: ArvGcPropertyNodeType = 19;
pub const ARV_GC_PROPERTY_NODE_TYPE_FORMULA_TO: ArvGcPropertyNodeType = 20;
pub const ARV_GC_PROPERTY_NODE_TYPE_FORMULA_FROM: ArvGcPropertyNodeType = 21;
pub const ARV_GC_PROPERTY_NODE_TYPE_EXPRESSION: ArvGcPropertyNodeType = 22;
pub const ARV_GC_PROPERTY_NODE_TYPE_CONSTANT: ArvGcPropertyNodeType = 23;
pub const ARV_GC_PROPERTY_NODE_TYPE_ACCESS_MODE: ArvGcPropertyNodeType = 24;
pub const ARV_GC_PROPERTY_NODE_TYPE_IMPOSED_ACCESS_MODE: ArvGcPropertyNodeType = 25;
pub const ARV_GC_PROPERTY_NODE_TYPE_CACHABLE: ArvGcPropertyNodeType = 26;
pub const ARV_GC_PROPERTY_NODE_TYPE_POLLING_TIME: ArvGcPropertyNodeType = 27;
pub const ARV_GC_PROPERTY_NODE_TYPE_ENDIANNESS: ArvGcPropertyNodeType = 28;
pub const ARV_GC_PROPERTY_NODE_TYPE_SIGN: ArvGcPropertyNodeType = 29;
pub const ARV_GC_PROPERTY_NODE_TYPE_LSB: ArvGcPropertyNodeType = 30;
pub const ARV_GC_PROPERTY_NODE_TYPE_MSB: ArvGcPropertyNodeType = 31;
pub const ARV_GC_PROPERTY_NODE_TYPE_BIT: ArvGcPropertyNodeType = 32;
pub const ARV_GC_PROPERTY_NODE_TYPE_COMMAND_VALUE: ArvGcPropertyNodeType = 33;
pub const ARV_GC_PROPERTY_NODE_TYPE_CHUNK_ID: ArvGcPropertyNodeType = 34;
pub const ARV_GC_PROPERTY_NODE_TYPE_EVENT_ID: ArvGcPropertyNodeType = 35;
pub const ARV_GC_PROPERTY_NODE_TYPE_VALUE_INDEXED: ArvGcPropertyNodeType = 36;
pub const ARV_GC_PROPERTY_NODE_TYPE_VALUE_DEFAULT: ArvGcPropertyNodeType = 37;
pub const ARV_GC_PROPERTY_NODE_TYPE_STREAMABLE: ArvGcPropertyNodeType = 38;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_UNKNONW: ArvGcPropertyNodeType = 1000;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_FEATURE: ArvGcPropertyNodeType = 1001;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_VALUE: ArvGcPropertyNodeType = 1002;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_ADDRESS: ArvGcPropertyNodeType = 1003;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_IS_IMPLEMENTED: ArvGcPropertyNodeType = 1004;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_IS_LOCKED: ArvGcPropertyNodeType = 1005;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_IS_AVAILABLE: ArvGcPropertyNodeType = 1006;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_SELECTED: ArvGcPropertyNodeType = 1007;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_MINIMUM: ArvGcPropertyNodeType = 1008;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_MAXIMUM: ArvGcPropertyNodeType = 1009;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_INCREMENT: ArvGcPropertyNodeType = 1010;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_INDEX: ArvGcPropertyNodeType = 1011;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_LENGTH: ArvGcPropertyNodeType = 1012;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_PORT: ArvGcPropertyNodeType = 1013;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_VARIABLE: ArvGcPropertyNodeType = 1014;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_INVALIDATOR: ArvGcPropertyNodeType = 1015;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_COMMAND_VALUE: ArvGcPropertyNodeType = 1016;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_INDEXED: ArvGcPropertyNodeType = 1017;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_DEFAULT: ArvGcPropertyNodeType = 1018;

pub type ArvGcRepresentation = c_int;
pub const ARV_GC_REPRESENTATION_UNDEFINED: ArvGcRepresentation = -1;
pub const ARV_GC_REPRESENTATION_LINEAR: ArvGcRepresentation = 0;
pub const ARV_GC_REPRESENTATION_LOGARITHMIC: ArvGcRepresentation = 1;
pub const ARV_GC_REPRESENTATION_BOOLEAN: ArvGcRepresentation = 2;
pub const ARV_GC_REPRESENTATION_PURE_NUMBER: ArvGcRepresentation = 3;
pub const ARV_GC_REPRESENTATION_HEX_NUMBER: ArvGcRepresentation = 4;
pub const ARV_GC_REPRESENTATION_IPV4_ADDRESS: ArvGcRepresentation = 5;
pub const ARV_GC_REPRESENTATION_MAC_ADDRESS: ArvGcRepresentation = 6;

pub type ArvGcSignedness = c_int;
pub const ARV_GC_SIGNEDNESS_UNDEFINED: ArvGcSignedness = -1;
pub const ARV_GC_SIGNEDNESS_SIGNED: ArvGcSignedness = 0;
pub const ARV_GC_SIGNEDNESS_UNSIGNED: ArvGcSignedness = 1;

pub type ArvGcStreamable = c_int;
pub const ARV_GC_STREAMABLE_UNDEFINED: ArvGcStreamable = -1;
pub const ARV_GC_STREAMABLE_NO: ArvGcStreamable = 0;
pub const ARV_GC_STREAMABLE_YES: ArvGcStreamable = 1;

pub type ArvGcVisibility = c_int;
pub const ARV_GC_VISIBILITY_UNDEFINED: ArvGcVisibility = -1;
pub const ARV_GC_VISIBILITY_INVISIBLE: ArvGcVisibility = 0;
pub const ARV_GC_VISIBILITY_GURU: ArvGcVisibility = 1;
pub const ARV_GC_VISIBILITY_EXPERT: ArvGcVisibility = 2;
pub const ARV_GC_VISIBILITY_BEGINNER: ArvGcVisibility = 3;

pub type ArvGvPacketSizeAdjustment = c_int;
pub const ARV_GV_PACKET_SIZE_ADJUSTMENT_NEVER: ArvGvPacketSizeAdjustment = 0;
pub const ARV_GV_PACKET_SIZE_ADJUSTMENT_ON_FAILURE_ONCE: ArvGvPacketSizeAdjustment = 1;
pub const ARV_GV_PACKET_SIZE_ADJUSTMENT_ON_FAILURE: ArvGvPacketSizeAdjustment = 2;
pub const ARV_GV_PACKET_SIZE_ADJUSTMENT_ONCE: ArvGvPacketSizeAdjustment = 3;
pub const ARV_GV_PACKET_SIZE_ADJUSTMENT_ALWAYS: ArvGvPacketSizeAdjustment = 4;
pub const ARV_GV_PACKET_SIZE_ADJUSTMENT_DEFAULT: ArvGvPacketSizeAdjustment = 1;

pub type ArvGvStreamOption = c_int;
pub const ARV_GV_STREAM_OPTION_NONE: ArvGvStreamOption = 0;
pub const ARV_GV_STREAM_OPTION_PACKET_SOCKET_DISABLED: ArvGvStreamOption = 1;

pub type ArvGvStreamPacketResend = c_int;
pub const ARV_GV_STREAM_PACKET_RESEND_NEVER: ArvGvStreamPacketResend = 0;
pub const ARV_GV_STREAM_PACKET_RESEND_ALWAYS: ArvGvStreamPacketResend = 1;

pub type ArvGvStreamSocketBuffer = c_int;
pub const ARV_GV_STREAM_SOCKET_BUFFER_FIXED: ArvGvStreamSocketBuffer = 0;
pub const ARV_GV_STREAM_SOCKET_BUFFER_AUTO: ArvGvStreamSocketBuffer = 1;

pub type ArvRangeCheckPolicy = c_int;
pub const ARV_RANGE_CHECK_POLICY_DISABLE: ArvRangeCheckPolicy = 0;
pub const ARV_RANGE_CHECK_POLICY_ENABLE: ArvRangeCheckPolicy = 1;
pub const ARV_RANGE_CHECK_POLICY_DEBUG: ArvRangeCheckPolicy = 2;
pub const ARV_RANGE_CHECK_POLICY_DEFAULT: ArvRangeCheckPolicy = 0;

pub type ArvRegisterCachePolicy = c_int;
pub const ARV_REGISTER_CACHE_POLICY_DISABLE: ArvRegisterCachePolicy = 0;
pub const ARV_REGISTER_CACHE_POLICY_ENABLE: ArvRegisterCachePolicy = 1;
pub const ARV_REGISTER_CACHE_POLICY_DEBUG: ArvRegisterCachePolicy = 2;
pub const ARV_REGISTER_CACHE_POLICY_DEFAULT: ArvRegisterCachePolicy = 0;

pub type ArvStreamCallbackType = c_int;
pub const ARV_STREAM_CALLBACK_TYPE_INIT: ArvStreamCallbackType = 0;
pub const ARV_STREAM_CALLBACK_TYPE_EXIT: ArvStreamCallbackType = 1;
pub const ARV_STREAM_CALLBACK_TYPE_START_BUFFER: ArvStreamCallbackType = 2;
pub const ARV_STREAM_CALLBACK_TYPE_BUFFER_DONE: ArvStreamCallbackType = 3;

pub type ArvXmlSchemaError = c_int;
pub const ARV_XML_SCHEMA_ERROR_INVALID_STRUCTURE: ArvXmlSchemaError = 0;

// Constants
pub const ARV_FAKE_CAMERA_ACQUISITION_FRAME_RATE_DEFAULT: c_double = 25.000000;
pub const ARV_FAKE_CAMERA_BINNING_HORIZONTAL_DEFAULT: c_int = 1;
pub const ARV_FAKE_CAMERA_BINNING_VERTICAL_DEFAULT: c_int = 1;
pub const ARV_FAKE_CAMERA_EXPOSURE_TIME_US_DEFAULT: c_double = 10000.000000;
pub const ARV_FAKE_CAMERA_HEIGHT_DEFAULT: c_int = 512;
pub const ARV_FAKE_CAMERA_MEMORY_SIZE: c_int = 65536;
pub const ARV_FAKE_CAMERA_REGISTER_ACQUISITION: c_int = 292;
pub const ARV_FAKE_CAMERA_REGISTER_ACQUISITION_FRAME_PERIOD_US: c_int = 312;
pub const ARV_FAKE_CAMERA_REGISTER_ACQUISITION_MODE: c_int = 300;
pub const ARV_FAKE_CAMERA_REGISTER_ACQUISITION_START_OFFSET: c_int = 32;
pub const ARV_FAKE_CAMERA_REGISTER_BINNING_HORIZONTAL: c_int = 264;
pub const ARV_FAKE_CAMERA_REGISTER_BINNING_VERTICAL: c_int = 268;
pub const ARV_FAKE_CAMERA_REGISTER_EXPOSURE_TIME_US: c_int = 288;
pub const ARV_FAKE_CAMERA_REGISTER_FRAME_START_OFFSET: c_int = 0;
pub const ARV_FAKE_CAMERA_REGISTER_GAIN_MODE: c_int = 276;
pub const ARV_FAKE_CAMERA_REGISTER_GAIN_RAW: c_int = 272;
pub const ARV_FAKE_CAMERA_REGISTER_HEIGHT: c_int = 260;
pub const ARV_FAKE_CAMERA_REGISTER_PIXEL_FORMAT: c_int = 296;
pub const ARV_FAKE_CAMERA_REGISTER_SENSOR_HEIGHT: c_int = 280;
pub const ARV_FAKE_CAMERA_REGISTER_SENSOR_WIDTH: c_int = 284;
pub const ARV_FAKE_CAMERA_REGISTER_TEST: c_int = 496;
pub const ARV_FAKE_CAMERA_REGISTER_TRIGGER_ACTIVATION: c_int = 776;
pub const ARV_FAKE_CAMERA_REGISTER_TRIGGER_MODE: c_int = 768;
pub const ARV_FAKE_CAMERA_REGISTER_TRIGGER_SOURCE: c_int = 772;
pub const ARV_FAKE_CAMERA_REGISTER_WIDTH: c_int = 256;
pub const ARV_FAKE_CAMERA_REGISTER_X_OFFSET: c_int = 304;
pub const ARV_FAKE_CAMERA_REGISTER_Y_OFFSET: c_int = 308;
pub const ARV_FAKE_CAMERA_SENSOR_HEIGHT: c_int = 2048;
pub const ARV_FAKE_CAMERA_SENSOR_WIDTH: c_int = 2048;
pub const ARV_FAKE_CAMERA_TEST_REGISTER_DEFAULT: c_int = 305419896;
pub const ARV_FAKE_CAMERA_WIDTH_DEFAULT: c_int = 512;
pub const ARV_GV_FAKE_CAMERA_DEFAULT_INTERFACE: *const c_char =
	b"lo\0" as *const u8 as *const c_char;
pub const ARV_GV_FAKE_CAMERA_DEFAULT_SERIAL_NUMBER: *const c_char =
	b"GV01\0" as *const u8 as *const c_char;
pub const ARV_PIXEL_FORMAT_BAYER_BG_10: ArvPixelFormat = 17825807;
pub const ARV_PIXEL_FORMAT_BAYER_BG_10P: ArvPixelFormat = 17432658;
pub const ARV_PIXEL_FORMAT_BAYER_BG_10_PACKED: ArvPixelFormat = 17563689;
pub const ARV_PIXEL_FORMAT_BAYER_BG_12: ArvPixelFormat = 17825811;
pub const ARV_PIXEL_FORMAT_BAYER_BG_12P: ArvPixelFormat = 17563731;
pub const ARV_PIXEL_FORMAT_BAYER_BG_12_PACKED: ArvPixelFormat = 17563693;
pub const ARV_PIXEL_FORMAT_BAYER_BG_16: ArvPixelFormat = 17825841;
pub const ARV_PIXEL_FORMAT_BAYER_BG_8: ArvPixelFormat = 17301515;
pub const ARV_PIXEL_FORMAT_BAYER_GB_10: ArvPixelFormat = 17825806;
pub const ARV_PIXEL_FORMAT_BAYER_GB_10P: ArvPixelFormat = 17432660;
pub const ARV_PIXEL_FORMAT_BAYER_GB_10_PACKED: ArvPixelFormat = 17563688;
pub const ARV_PIXEL_FORMAT_BAYER_GB_12: ArvPixelFormat = 17825810;
pub const ARV_PIXEL_FORMAT_BAYER_GB_12P: ArvPixelFormat = 17563733;
pub const ARV_PIXEL_FORMAT_BAYER_GB_12_PACKED: ArvPixelFormat = 17563692;
pub const ARV_PIXEL_FORMAT_BAYER_GB_16: ArvPixelFormat = 17825840;
pub const ARV_PIXEL_FORMAT_BAYER_GB_8: ArvPixelFormat = 17301514;
pub const ARV_PIXEL_FORMAT_BAYER_GR_10: ArvPixelFormat = 17825804;
pub const ARV_PIXEL_FORMAT_BAYER_GR_10P: ArvPixelFormat = 17432662;
pub const ARV_PIXEL_FORMAT_BAYER_GR_10_PACKED: ArvPixelFormat = 17563686;
pub const ARV_PIXEL_FORMAT_BAYER_GR_12: ArvPixelFormat = 17825808;
pub const ARV_PIXEL_FORMAT_BAYER_GR_12P: ArvPixelFormat = 17563735;
pub const ARV_PIXEL_FORMAT_BAYER_GR_12_PACKED: ArvPixelFormat = 17563690;
pub const ARV_PIXEL_FORMAT_BAYER_GR_16: ArvPixelFormat = 17825838;
pub const ARV_PIXEL_FORMAT_BAYER_GR_8: ArvPixelFormat = 17301512;
pub const ARV_PIXEL_FORMAT_BAYER_RG_10: ArvPixelFormat = 17825805;
pub const ARV_PIXEL_FORMAT_BAYER_RG_10P: ArvPixelFormat = 17432664;
pub const ARV_PIXEL_FORMAT_BAYER_RG_10_PACKED: ArvPixelFormat = 17563687;
pub const ARV_PIXEL_FORMAT_BAYER_RG_12: ArvPixelFormat = 17825809;
pub const ARV_PIXEL_FORMAT_BAYER_RG_12P: ArvPixelFormat = 17563737;
pub const ARV_PIXEL_FORMAT_BAYER_RG_12_PACKED: ArvPixelFormat = 17563691;
pub const ARV_PIXEL_FORMAT_BAYER_RG_16: ArvPixelFormat = 17825839;
pub const ARV_PIXEL_FORMAT_BAYER_RG_8: ArvPixelFormat = 17301513;
pub const ARV_PIXEL_FORMAT_BGRA_8_PACKED: ArvPixelFormat = 35651607;
pub const ARV_PIXEL_FORMAT_BGR_10_PACKED: ArvPixelFormat = 36700185;
pub const ARV_PIXEL_FORMAT_BGR_12_PACKED: ArvPixelFormat = 36700187;
pub const ARV_PIXEL_FORMAT_BGR_8_PACKED: ArvPixelFormat = 35127317;
pub const ARV_PIXEL_FORMAT_CUSTOM_BAYER_BG_12_PACKED: ArvPixelFormat = 2165047300;
pub const ARV_PIXEL_FORMAT_CUSTOM_BAYER_BG_16: ArvPixelFormat = 2165309449;
pub const ARV_PIXEL_FORMAT_CUSTOM_BAYER_GB_12_PACKED: ArvPixelFormat = 2165047299;
pub const ARV_PIXEL_FORMAT_CUSTOM_BAYER_GB_16: ArvPixelFormat = 2165309448;
pub const ARV_PIXEL_FORMAT_CUSTOM_BAYER_GR_12_PACKED: ArvPixelFormat = 2165047297;
pub const ARV_PIXEL_FORMAT_CUSTOM_BAYER_GR_16: ArvPixelFormat = 2165309446;
pub const ARV_PIXEL_FORMAT_CUSTOM_BAYER_RG_12_PACKED: ArvPixelFormat = 2165047298;
pub const ARV_PIXEL_FORMAT_CUSTOM_BAYER_RG_16: ArvPixelFormat = 2165309447;
pub const ARV_PIXEL_FORMAT_CUSTOM_YUV_422_YUYV_PACKED: ArvPixelFormat = 2182086661;
pub const ARV_PIXEL_FORMAT_MONO_10: ArvPixelFormat = 17825795;
pub const ARV_PIXEL_FORMAT_MONO_10_PACKED: ArvPixelFormat = 17563652;
pub const ARV_PIXEL_FORMAT_MONO_12: ArvPixelFormat = 17825797;
pub const ARV_PIXEL_FORMAT_MONO_12_PACKED: ArvPixelFormat = 17563654;
pub const ARV_PIXEL_FORMAT_MONO_14: ArvPixelFormat = 17825829;
pub const ARV_PIXEL_FORMAT_MONO_16: ArvPixelFormat = 17825799;
pub const ARV_PIXEL_FORMAT_MONO_8: ArvPixelFormat = 17301505;
pub const ARV_PIXEL_FORMAT_MONO_8_SIGNED: ArvPixelFormat = 17301506;
pub const ARV_PIXEL_FORMAT_RGBA_8_PACKED: ArvPixelFormat = 35651606;
pub const ARV_PIXEL_FORMAT_RGB_10_PACKED: ArvPixelFormat = 36700184;
pub const ARV_PIXEL_FORMAT_RGB_10_PLANAR: ArvPixelFormat = 36700194;
pub const ARV_PIXEL_FORMAT_RGB_12_PACKED: ArvPixelFormat = 36700186;
pub const ARV_PIXEL_FORMAT_RGB_12_PLANAR: ArvPixelFormat = 36700195;
pub const ARV_PIXEL_FORMAT_RGB_16_PLANAR: ArvPixelFormat = 36700196;
pub const ARV_PIXEL_FORMAT_RGB_8_PACKED: ArvPixelFormat = 35127316;
pub const ARV_PIXEL_FORMAT_RGB_8_PLANAR: ArvPixelFormat = 35127329;
pub const ARV_PIXEL_FORMAT_YUV_411_PACKED: ArvPixelFormat = 34340894;
pub const ARV_PIXEL_FORMAT_YUV_422_PACKED: ArvPixelFormat = 34603039;
pub const ARV_PIXEL_FORMAT_YUV_422_YUYV_PACKED: ArvPixelFormat = 34603058;
pub const ARV_PIXEL_FORMAT_YUV_444_PACKED: ArvPixelFormat = 35127328;

// Callbacks
pub type ArvDomDocumentCreateFunction = Option<unsafe extern "C" fn() -> *mut ArvDomDocument>;
pub type ArvFakeCameraFillPattern =
	Option<unsafe extern "C" fn(*mut ArvBuffer, *mut c_void, u32, u32, ArvPixelFormat)>;
pub type ArvFrameCallback = Option<unsafe extern "C" fn(*mut ArvBuffer)>;
pub type ArvStreamCallback =
	Option<unsafe extern "C" fn(*mut c_void, ArvStreamCallbackType, *mut ArvBuffer)>;

// Records
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvBufferClass {
	pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for ArvBufferClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvBufferClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvCameraClass {
	pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for ArvCameraClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvCameraClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvChunkParserClass {
	pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for ArvChunkParserClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvChunkParserClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDeviceClass {
	pub parent_class: gobject::GObjectClass,
	pub create_stream: Option<
		unsafe extern "C" fn(
			*mut ArvDevice,
			ArvStreamCallback,
			*mut c_void,
			*mut *mut glib::GError,
		) -> *mut ArvStream,
	>,
	pub get_genicam_xml: Option<unsafe extern "C" fn(*mut ArvDevice, *mut size_t) -> *const c_char>,
	pub get_genicam: Option<unsafe extern "C" fn(*mut ArvDevice) -> *mut ArvGc>,
	pub read_memory: Option<
		unsafe extern "C" fn(
			*mut ArvDevice,
			u64,
			u32,
			*mut c_void,
			*mut *mut glib::GError,
		) -> gboolean,
	>,
	pub write_memory: Option<
		unsafe extern "C" fn(
			*mut ArvDevice,
			u64,
			u32,
			*mut c_void,
			*mut *mut glib::GError,
		) -> gboolean,
	>,
	pub read_register:
		Option<unsafe extern "C" fn(*mut ArvDevice, u64, u32, *mut *mut glib::GError) -> gboolean>,
	pub write_register:
		Option<unsafe extern "C" fn(*mut ArvDevice, u64, u32, *mut *mut glib::GError) -> gboolean>,
	pub control_lost: Option<unsafe extern "C" fn(*mut ArvDevice)>,
}

impl ::std::fmt::Debug for ArvDeviceClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDeviceClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.field("create_stream", &self.create_stream)
			.field("get_genicam_xml", &self.get_genicam_xml)
			.field("get_genicam", &self.get_genicam)
			.field("read_memory", &self.read_memory)
			.field("write_memory", &self.write_memory)
			.field("read_register", &self.read_register)
			.field("write_register", &self.write_register)
			.field("control_lost", &self.control_lost)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomCharacterDataClass {
	pub parent_class: ArvDomNodeClass,
}

impl ::std::fmt::Debug for ArvDomCharacterDataClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomCharacterDataClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomDocumentClass {
	pub parent_class: ArvDomNodeClass,
	pub get_document_element:
		Option<unsafe extern "C" fn(*mut ArvDomDocument) -> *mut ArvDomElement>,
	pub create_element:
		Option<unsafe extern "C" fn(*mut ArvDomDocument, *const c_char) -> *mut ArvDomElement>,
	pub create_text_node:
		Option<unsafe extern "C" fn(*mut ArvDomDocument, *const c_char) -> *mut ArvDomText>,
}

impl ::std::fmt::Debug for ArvDomDocumentClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomDocumentClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.field("get_document_element", &self.get_document_element)
			.field("create_element", &self.create_element)
			.field("create_text_node", &self.create_text_node)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomDocumentFragmentClass {
	pub parent_class: ArvDomNodeClass,
}

impl ::std::fmt::Debug for ArvDomDocumentFragmentClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomDocumentFragmentClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomElementClass {
	pub parent_class: ArvDomNodeClass,
	pub get_attribute:
		Option<unsafe extern "C" fn(*mut ArvDomElement, *const c_char) -> *const c_char>,
	pub set_attribute:
		Option<unsafe extern "C" fn(*mut ArvDomElement, *const c_char, *const c_char)>,
}

impl ::std::fmt::Debug for ArvDomElementClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomElementClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.field("get_attribute", &self.get_attribute)
			.field("set_attribute", &self.set_attribute)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomNamedNodeMapClass {
	pub parent_class: gobject::GObjectClass,
	pub get:
		Option<unsafe extern "C" fn(*mut ArvDomNamedNodeMap, *const c_char) -> *mut ArvDomNode>,
	pub set:
		Option<unsafe extern "C" fn(*mut ArvDomNamedNodeMap, *mut ArvDomNode) -> *mut ArvDomNode>,
	pub remove:
		Option<unsafe extern "C" fn(*mut ArvDomNamedNodeMap, *const c_char) -> *mut ArvDomNode>,
	pub get_item: Option<unsafe extern "C" fn(*mut ArvDomNamedNodeMap, c_uint) -> *mut ArvDomNode>,
	pub get_length: Option<unsafe extern "C" fn(*mut ArvDomNamedNodeMap) -> c_uint>,
}

impl ::std::fmt::Debug for ArvDomNamedNodeMapClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomNamedNodeMapClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.field("get", &self.get)
			.field("set", &self.set)
			.field("remove", &self.remove)
			.field("get_item", &self.get_item)
			.field("get_length", &self.get_length)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomNodeChildListClass {
	pub parent_class: ArvDomNodeListClass,
}

impl ::std::fmt::Debug for ArvDomNodeChildListClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomNodeChildListClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomNodeClass {
	pub parent_class: gobject::GObjectClass,
	pub get_node_name: Option<unsafe extern "C" fn(*mut ArvDomNode) -> *const c_char>,
	pub get_node_value: Option<unsafe extern "C" fn(*mut ArvDomNode) -> *const c_char>,
	pub set_node_value: Option<unsafe extern "C" fn(*mut ArvDomNode, *const c_char)>,
	pub get_node_type: Option<unsafe extern "C" fn(*mut ArvDomNode) -> ArvDomNodeType>,
	pub can_append_child:
		Option<unsafe extern "C" fn(*mut ArvDomNode, *mut ArvDomNode) -> gboolean>,
	pub post_new_child: Option<unsafe extern "C" fn(*mut ArvDomNode, *mut ArvDomNode)>,
	pub pre_remove_child: Option<unsafe extern "C" fn(*mut ArvDomNode, *mut ArvDomNode)>,
	pub changed: Option<unsafe extern "C" fn(*mut ArvDomNode)>,
	pub child_changed: Option<unsafe extern "C" fn(*mut ArvDomNode, *mut ArvDomNode) -> gboolean>,
}

impl ::std::fmt::Debug for ArvDomNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.field("get_node_name", &self.get_node_name)
			.field("get_node_value", &self.get_node_value)
			.field("set_node_value", &self.set_node_value)
			.field("get_node_type", &self.get_node_type)
			.field("can_append_child", &self.can_append_child)
			.field("post_new_child", &self.post_new_child)
			.field("pre_remove_child", &self.pre_remove_child)
			.field("changed", &self.changed)
			.field("child_changed", &self.child_changed)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomNodeListClass {
	pub parent_class: gobject::GObjectClass,
	pub get_item: Option<unsafe extern "C" fn(*mut ArvDomNodeList, c_uint) -> *mut ArvDomNode>,
	pub get_length: Option<unsafe extern "C" fn(*mut ArvDomNodeList) -> c_uint>,
}

impl ::std::fmt::Debug for ArvDomNodeListClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomNodeListClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.field("get_item", &self.get_item)
			.field("get_length", &self.get_length)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomTextClass {
	pub parent_class: ArvDomCharacterDataClass,
}

impl ::std::fmt::Debug for ArvDomTextClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomTextClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvEvaluatorClass {
	pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for ArvEvaluatorClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvEvaluatorClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvFakeCameraClass {
	pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for ArvFakeCameraClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvFakeCameraClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvFakeDeviceClass {
	pub parent_class: ArvDeviceClass,
}

impl ::std::fmt::Debug for ArvFakeDeviceClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvFakeDeviceClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvFakeInterfaceClass {
	pub parent_class: ArvInterfaceClass,
}

impl ::std::fmt::Debug for ArvFakeInterfaceClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvFakeInterfaceClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvFakeStreamClass {
	pub parent_class: ArvStreamClass,
}

impl ::std::fmt::Debug for ArvFakeStreamClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvFakeStreamClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcBooleanClass {
	pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcBooleanClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcBooleanClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcCategoryClass {
	pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcCategoryClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcCategoryClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcClass {
	pub parent_class: ArvDomDocumentClass,
}

impl ::std::fmt::Debug for ArvGcClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcCommandClass {
	pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcCommandClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcCommandClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcConverterClass {
	pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcConverterClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcConverterClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcConverterNodeClass {
	pub parent_class: ArvGcConverterClass,
}

impl ::std::fmt::Debug for ArvGcConverterNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcConverterNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcEnumEntryClass {
	pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcEnumEntryClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcEnumEntryClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcEnumerationClass {
	pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcEnumerationClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcEnumerationClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcFeatureNodeClass {
	pub parent_class: ArvGcNodeClass,
	pub get_linked_feature:
		Option<unsafe extern "C" fn(*mut ArvGcFeatureNode) -> *mut ArvGcFeatureNode>,
	pub get_access_mode: Option<unsafe extern "C" fn(*mut ArvGcFeatureNode) -> ArvGcAccessMode>,
}

impl ::std::fmt::Debug for ArvGcFeatureNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcFeatureNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.field("get_linked_feature", &self.get_linked_feature)
			.field("get_access_mode", &self.get_access_mode)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcFloatInterface {
	pub parent: gobject::GTypeInterface,
	pub get_value:
		Option<unsafe extern "C" fn(*mut ArvGcFloat, *mut *mut glib::GError) -> c_double>,
	pub set_value: Option<unsafe extern "C" fn(*mut ArvGcFloat, c_double, *mut *mut glib::GError)>,
	pub get_min: Option<unsafe extern "C" fn(*mut ArvGcFloat, *mut *mut glib::GError) -> c_double>,
	pub get_max: Option<unsafe extern "C" fn(*mut ArvGcFloat, *mut *mut glib::GError) -> c_double>,
	pub get_inc: Option<unsafe extern "C" fn(*mut ArvGcFloat, *mut *mut glib::GError) -> c_double>,
	pub get_representation: Option<unsafe extern "C" fn(*mut ArvGcFloat) -> ArvGcRepresentation>,
	pub get_display_notation: Option<unsafe extern "C" fn(*mut ArvGcFloat) -> ArvGcDisplayNotation>,
	pub get_display_precision: Option<unsafe extern "C" fn(*mut ArvGcFloat) -> i64>,
	pub get_unit: Option<unsafe extern "C" fn(*mut ArvGcFloat) -> *const c_char>,
	pub impose_min: Option<unsafe extern "C" fn(*mut ArvGcFloat, c_double, *mut *mut glib::GError)>,
	pub impose_max: Option<unsafe extern "C" fn(*mut ArvGcFloat, c_double, *mut *mut glib::GError)>,
}

impl ::std::fmt::Debug for ArvGcFloatInterface {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcFloatInterface @ {:p}", self))
			.field("parent", &self.parent)
			.field("get_value", &self.get_value)
			.field("set_value", &self.set_value)
			.field("get_min", &self.get_min)
			.field("get_max", &self.get_max)
			.field("get_inc", &self.get_inc)
			.field("get_representation", &self.get_representation)
			.field("get_display_notation", &self.get_display_notation)
			.field("get_display_precision", &self.get_display_precision)
			.field("get_unit", &self.get_unit)
			.field("impose_min", &self.impose_min)
			.field("impose_max", &self.impose_max)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcFloatNodeClass {
	pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcFloatNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcFloatNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcFloatRegNodeClass {
	pub parent_class: ArvGcRegisterNodeClass,
}

impl ::std::fmt::Debug for ArvGcFloatRegNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcFloatRegNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcGroupNodeClass {
	pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcGroupNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcGroupNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcIndexNodeClass {
	pub parent_class: ArvGcPropertyNodeClass,
}

impl ::std::fmt::Debug for ArvGcIndexNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcIndexNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcIntConverterNodeClass {
	pub parent_class: ArvGcConverterClass,
}

impl ::std::fmt::Debug for ArvGcIntConverterNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcIntConverterNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcIntRegNodeClass {
	pub parent_class: ArvGcRegisterNodeClass,
}

impl ::std::fmt::Debug for ArvGcIntRegNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcIntRegNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcIntSwissKnifeNodeClass {
	pub parent_class: ArvGcSwissKnifeClass,
}

impl ::std::fmt::Debug for ArvGcIntSwissKnifeNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcIntSwissKnifeNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcIntegerInterface {
	pub parent: gobject::GTypeInterface,
	pub get_value: Option<unsafe extern "C" fn(*mut ArvGcInteger, *mut *mut glib::GError) -> i64>,
	pub set_value: Option<unsafe extern "C" fn(*mut ArvGcInteger, i64, *mut *mut glib::GError)>,
	pub get_min: Option<unsafe extern "C" fn(*mut ArvGcInteger, *mut *mut glib::GError) -> i64>,
	pub get_max: Option<unsafe extern "C" fn(*mut ArvGcInteger, *mut *mut glib::GError) -> i64>,
	pub get_inc: Option<unsafe extern "C" fn(*mut ArvGcInteger, *mut *mut glib::GError) -> i64>,
	pub get_representation: Option<unsafe extern "C" fn(*mut ArvGcInteger) -> ArvGcRepresentation>,
	pub get_unit: Option<unsafe extern "C" fn(*mut ArvGcInteger) -> *const c_char>,
	pub impose_min: Option<unsafe extern "C" fn(*mut ArvGcInteger, i64, *mut *mut glib::GError)>,
	pub impose_max: Option<unsafe extern "C" fn(*mut ArvGcInteger, i64, *mut *mut glib::GError)>,
}

impl ::std::fmt::Debug for ArvGcIntegerInterface {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcIntegerInterface @ {:p}", self))
			.field("parent", &self.parent)
			.field("get_value", &self.get_value)
			.field("set_value", &self.set_value)
			.field("get_min", &self.get_min)
			.field("get_max", &self.get_max)
			.field("get_inc", &self.get_inc)
			.field("get_representation", &self.get_representation)
			.field("get_unit", &self.get_unit)
			.field("impose_min", &self.impose_min)
			.field("impose_max", &self.impose_max)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcIntegerNodeClass {
	pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcIntegerNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcIntegerNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcInvalidatorNodeClass {
	pub parent_class: ArvGcPropertyNodeClass,
}

impl ::std::fmt::Debug for ArvGcInvalidatorNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcInvalidatorNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcMaskedIntRegNodeClass {
	pub parent_class: ArvGcRegisterNodeClass,
}

impl ::std::fmt::Debug for ArvGcMaskedIntRegNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcMaskedIntRegNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcNodeClass {
	pub parent_class: ArvDomElementClass,
}

impl ::std::fmt::Debug for ArvGcNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcPortClass {
	pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcPortClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcPortClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcPropertyNodeClass {
	pub parent_class: ArvGcNodeClass,
}

impl ::std::fmt::Debug for ArvGcPropertyNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcPropertyNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcRegisterDescriptionNodeClass {
	pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcRegisterDescriptionNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcRegisterDescriptionNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcRegisterInterface {
	pub parent: gobject::GTypeInterface,
	pub get:
		Option<unsafe extern "C" fn(*mut ArvGcRegister, *mut c_void, u64, *mut *mut glib::GError)>,
	pub set:
		Option<unsafe extern "C" fn(*mut ArvGcRegister, *mut c_void, u64, *mut *mut glib::GError)>,
	pub get_address:
		Option<unsafe extern "C" fn(*mut ArvGcRegister, *mut *mut glib::GError) -> u64>,
	pub get_length: Option<unsafe extern "C" fn(*mut ArvGcRegister, *mut *mut glib::GError) -> u64>,
}

impl ::std::fmt::Debug for ArvGcRegisterInterface {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcRegisterInterface @ {:p}", self))
			.field("parent", &self.parent)
			.field("get", &self.get)
			.field("set", &self.set)
			.field("get_address", &self.get_address)
			.field("get_length", &self.get_length)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcRegisterNodeClass {
	pub parent_class: ArvGcFeatureNodeClass,
	pub default_cachable: ArvGcCachable,
}

impl ::std::fmt::Debug for ArvGcRegisterNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcRegisterNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.field("default_cachable", &self.default_cachable)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcSelectorInterface {
	pub parent: gobject::GTypeInterface,
	pub get_selected_features:
		Option<unsafe extern "C" fn(*mut ArvGcSelector) -> *const glib::GSList>,
}

impl ::std::fmt::Debug for ArvGcSelectorInterface {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcSelectorInterface @ {:p}", self))
			.field("parent", &self.parent)
			.field("get_selected_features", &self.get_selected_features)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcStringInterface {
	pub parent: gobject::GTypeInterface,
	pub get_value:
		Option<unsafe extern "C" fn(*mut ArvGcString, *mut *mut glib::GError) -> *const c_char>,
	pub set_value:
		Option<unsafe extern "C" fn(*mut ArvGcString, *const c_char, *mut *mut glib::GError)>,
	pub get_max_length:
		Option<unsafe extern "C" fn(*mut ArvGcString, *mut *mut glib::GError) -> i64>,
}

impl ::std::fmt::Debug for ArvGcStringInterface {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcStringInterface @ {:p}", self))
			.field("parent", &self.parent)
			.field("get_value", &self.get_value)
			.field("set_value", &self.set_value)
			.field("get_max_length", &self.get_max_length)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcStringNodeClass {
	pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcStringNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcStringNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcStringRegNodeClass {
	pub parent_class: ArvGcRegisterNodeClass,
}

impl ::std::fmt::Debug for ArvGcStringRegNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcStringRegNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcStructEntryNodeClass {
	pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcStructEntryNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcStructEntryNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcStructRegNodeClass {
	pub parent_class: ArvGcRegisterNodeClass,
}

impl ::std::fmt::Debug for ArvGcStructRegNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcStructRegNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcSwissKnifeClass {
	pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcSwissKnifeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcSwissKnifeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcSwissKnifeNodeClass {
	pub parent_class: ArvGcSwissKnifeClass,
}

impl ::std::fmt::Debug for ArvGcSwissKnifeNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcSwissKnifeNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcValueIndexedNodeClass {
	pub parent_class: ArvGcPropertyNodeClass,
}

impl ::std::fmt::Debug for ArvGcValueIndexedNodeClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcValueIndexedNodeClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGvDeviceClass {
	pub parent_class: ArvDeviceClass,
}

impl ::std::fmt::Debug for ArvGvDeviceClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGvDeviceClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGvFakeCameraClass {
	pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for ArvGvFakeCameraClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGvFakeCameraClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGvInterfaceClass {
	pub parent_class: ArvInterfaceClass,
}

impl ::std::fmt::Debug for ArvGvInterfaceClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGvInterfaceClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGvStreamClass {
	pub parent_class: ArvStreamClass,
}

impl ::std::fmt::Debug for ArvGvStreamClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGvStreamClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvInterfaceClass {
	pub parent_class: gobject::GObjectClass,
	pub update_device_list: Option<unsafe extern "C" fn(*mut ArvInterface, *mut glib::GArray)>,
	pub open_device: Option<
		unsafe extern "C" fn(
			*mut ArvInterface,
			*const c_char,
			*mut *mut glib::GError,
		) -> *mut ArvDevice,
	>,
	pub protocol: *const c_char,
}

impl ::std::fmt::Debug for ArvInterfaceClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvInterfaceClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.field("update_device_list", &self.update_device_list)
			.field("open_device", &self.open_device)
			.field("protocol", &self.protocol)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvStreamClass {
	pub parent_class: gobject::GObjectClass,
	pub start_thread: Option<unsafe extern "C" fn(*mut ArvStream)>,
	pub stop_thread: Option<unsafe extern "C" fn(*mut ArvStream)>,
	pub new_buffer: Option<unsafe extern "C" fn(*mut ArvStream)>,
}

impl ::std::fmt::Debug for ArvStreamClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvStreamClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.field("start_thread", &self.start_thread)
			.field("stop_thread", &self.stop_thread)
			.field("new_buffer", &self.new_buffer)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvUvDeviceClass {
	pub parent_class: ArvDeviceClass,
}

impl ::std::fmt::Debug for ArvUvDeviceClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvUvDeviceClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvUvInterfaceClass {
	pub parent_class: ArvInterfaceClass,
}

impl ::std::fmt::Debug for ArvUvInterfaceClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvUvInterfaceClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvUvStreamClass {
	pub parent_class: ArvStreamClass,
}

impl ::std::fmt::Debug for ArvUvStreamClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvUvStreamClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvXmlSchemaClass {
	pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for ArvXmlSchemaClass {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvXmlSchemaClass @ {:p}", self))
			.field("parent_class", &self.parent_class)
			.finish()
	}
}

#[repr(C)]
pub struct _ArvZip(c_void);

pub type ArvZip = *mut _ArvZip;

#[repr(C)]
pub struct _ArvZipFile(c_void);

pub type ArvZipFile = *mut _ArvZipFile;

// Classes
#[repr(C)]
pub struct ArvBuffer(c_void);

impl ::std::fmt::Debug for ArvBuffer {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvBuffer @ {:p}", self)).finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvCamera {
	pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for ArvCamera {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvCamera @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
pub struct ArvChunkParser(c_void);

impl ::std::fmt::Debug for ArvChunkParser {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvChunkParser @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDevice {
	pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for ArvDevice {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDevice @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomCharacterData {
	pub parent_instance: ArvDomNode,
}

impl ::std::fmt::Debug for ArvDomCharacterData {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomCharacterData @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomDocument {
	pub parent_instance: ArvDomNode,
}

impl ::std::fmt::Debug for ArvDomDocument {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomDocument @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomDocumentFragment {
	pub parent_instance: ArvDomNode,
}

impl ::std::fmt::Debug for ArvDomDocumentFragment {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomDocumentFragment @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomElement {
	pub parent_instance: ArvDomNode,
}

impl ::std::fmt::Debug for ArvDomElement {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomElement @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomNamedNodeMap {
	pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for ArvDomNamedNodeMap {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomNamedNodeMap @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomNode {
	pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for ArvDomNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomNode @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
pub struct ArvDomNodeChildList(c_void);

impl ::std::fmt::Debug for ArvDomNodeChildList {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomNodeChildList @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomNodeList {
	pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for ArvDomNodeList {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomNodeList @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomText {
	pub parent_instance: ArvDomCharacterData,
}

impl ::std::fmt::Debug for ArvDomText {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvDomText @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
pub struct ArvEvaluator(c_void);

impl ::std::fmt::Debug for ArvEvaluator {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvEvaluator @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvFakeCamera(c_void);

impl ::std::fmt::Debug for ArvFakeCamera {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvFakeCamera @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvFakeDevice(c_void);

impl ::std::fmt::Debug for ArvFakeDevice {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvFakeDevice @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvFakeInterface(c_void);

impl ::std::fmt::Debug for ArvFakeInterface {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvFakeInterface @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvFakeStream(c_void);

impl ::std::fmt::Debug for ArvFakeStream {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvFakeStream @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvGc(c_void);

impl ::std::fmt::Debug for ArvGc {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGc @ {:p}", self)).finish()
	}
}

#[repr(C)]
pub struct ArvGcBoolean(c_void);

impl ::std::fmt::Debug for ArvGcBoolean {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcBoolean @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvGcCategory(c_void);

impl ::std::fmt::Debug for ArvGcCategory {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcCategory @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvGcCommand(c_void);

impl ::std::fmt::Debug for ArvGcCommand {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcCommand @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcConverter {
	pub parent_instance: ArvGcFeatureNode,
}

impl ::std::fmt::Debug for ArvGcConverter {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcConverter @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
pub struct ArvGcConverterNode(c_void);

impl ::std::fmt::Debug for ArvGcConverterNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcConverterNode @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvGcEnumEntry(c_void);

impl ::std::fmt::Debug for ArvGcEnumEntry {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcEnumEntry @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvGcEnumeration(c_void);

impl ::std::fmt::Debug for ArvGcEnumeration {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcEnumeration @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcFeatureNode {
	pub parent_instance: ArvGcNode,
}

impl ::std::fmt::Debug for ArvGcFeatureNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcFeatureNode @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
pub struct ArvGcFloatNode(c_void);

impl ::std::fmt::Debug for ArvGcFloatNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcFloatNode @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcFloatRegNode {
	pub parent_instance: ArvGcRegisterNode,
}

impl ::std::fmt::Debug for ArvGcFloatRegNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcFloatRegNode @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
pub struct ArvGcGroupNode(c_void);

impl ::std::fmt::Debug for ArvGcGroupNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcGroupNode @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvGcIndexNode(c_void);

impl ::std::fmt::Debug for ArvGcIndexNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcIndexNode @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvGcIntConverterNode(c_void);

impl ::std::fmt::Debug for ArvGcIntConverterNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcIntConverterNode @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcIntRegNode {
	pub parent_instance: ArvGcRegisterNode,
}

impl ::std::fmt::Debug for ArvGcIntRegNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcIntRegNode @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcIntSwissKnifeNode {
	pub parent_instance: ArvGcSwissKnife,
}

impl ::std::fmt::Debug for ArvGcIntSwissKnifeNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcIntSwissKnifeNode @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
pub struct ArvGcIntegerNode(c_void);

impl ::std::fmt::Debug for ArvGcIntegerNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcIntegerNode @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvGcInvalidatorNode(c_void);

impl ::std::fmt::Debug for ArvGcInvalidatorNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcInvalidatorNode @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcMaskedIntRegNode {
	pub parent_instance: ArvGcRegisterNode,
}

impl ::std::fmt::Debug for ArvGcMaskedIntRegNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcMaskedIntRegNode @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcNode {
	pub parent_instance: ArvDomElement,
}

impl ::std::fmt::Debug for ArvGcNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcNode @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
pub struct ArvGcPort(c_void);

impl ::std::fmt::Debug for ArvGcPort {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcPort @ {:p}", self)).finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcPropertyNode {
	pub parent_instance: ArvGcNode,
}

impl ::std::fmt::Debug for ArvGcPropertyNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcPropertyNode @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
pub struct ArvGcRegisterDescriptionNode(c_void);

impl ::std::fmt::Debug for ArvGcRegisterDescriptionNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcRegisterDescriptionNode @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcRegisterNode {
	pub parent_instance: ArvGcFeatureNode,
}

impl ::std::fmt::Debug for ArvGcRegisterNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcRegisterNode @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
pub struct ArvGcStringNode(c_void);

impl ::std::fmt::Debug for ArvGcStringNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcStringNode @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcStringRegNode {
	pub parent_instance: ArvGcRegisterNode,
}

impl ::std::fmt::Debug for ArvGcStringRegNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcStringRegNode @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
pub struct ArvGcStructEntryNode(c_void);

impl ::std::fmt::Debug for ArvGcStructEntryNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcStructEntryNode @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcStructRegNode {
	pub parent_instance: ArvGcRegisterNode,
}

impl ::std::fmt::Debug for ArvGcStructRegNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcStructRegNode @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcSwissKnife {
	pub parent_instance: ArvGcFeatureNode,
}

impl ::std::fmt::Debug for ArvGcSwissKnife {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcSwissKnife @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcSwissKnifeNode {
	pub parent_instance: ArvGcSwissKnife,
}

impl ::std::fmt::Debug for ArvGcSwissKnifeNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcSwissKnifeNode @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
pub struct ArvGcValueIndexedNode(c_void);

impl ::std::fmt::Debug for ArvGcValueIndexedNode {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGcValueIndexedNode @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvGvDevice(c_void);

impl ::std::fmt::Debug for ArvGvDevice {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGvDevice @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvGvFakeCamera(c_void);

impl ::std::fmt::Debug for ArvGvFakeCamera {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGvFakeCamera @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvGvInterface(c_void);

impl ::std::fmt::Debug for ArvGvInterface {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGvInterface @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvGvStream(c_void);

impl ::std::fmt::Debug for ArvGvStream {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvGvStream @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvInterface {
	pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for ArvInterface {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvInterface @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvStream {
	pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for ArvStream {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvStream @ {:p}", self))
			.field("parent_instance", &self.parent_instance)
			.finish()
	}
}

#[repr(C)]
pub struct ArvUvDevice(c_void);

impl ::std::fmt::Debug for ArvUvDevice {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvUvDevice @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvUvInterface(c_void);

impl ::std::fmt::Debug for ArvUvInterface {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvUvInterface @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvUvStream(c_void);

impl ::std::fmt::Debug for ArvUvStream {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvUvStream @ {:p}", self))
			.finish()
	}
}

#[repr(C)]
pub struct ArvXmlSchema(c_void);

impl ::std::fmt::Debug for ArvXmlSchema {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		f.debug_struct(&format!("ArvXmlSchema @ {:p}", self))
			.finish()
	}
}

// Interfaces
#[repr(C)]
pub struct ArvGcFloat(c_void);

impl ::std::fmt::Debug for ArvGcFloat {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		write!(f, "ArvGcFloat @ {:p}", self)
	}
}

#[repr(C)]
pub struct ArvGcInteger(c_void);

impl ::std::fmt::Debug for ArvGcInteger {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		write!(f, "ArvGcInteger @ {:p}", self)
	}
}

#[repr(C)]
pub struct ArvGcRegister(c_void);

impl ::std::fmt::Debug for ArvGcRegister {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		write!(f, "ArvGcRegister @ {:p}", self)
	}
}

#[repr(C)]
pub struct ArvGcSelector(c_void);

impl ::std::fmt::Debug for ArvGcSelector {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		write!(f, "ArvGcSelector @ {:p}", self)
	}
}

#[repr(C)]
pub struct ArvGcString(c_void);

impl ::std::fmt::Debug for ArvGcString {
	fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
		write!(f, "ArvGcString @ {:p}", self)
	}
}

#[link(name = "aravis-0.8")]
extern "C" {

	//=========================================================================
	// ArvAcquisitionMode
	//=========================================================================
	pub fn arv_acquisition_mode_get_type() -> GType;
	pub fn arv_acquisition_mode_from_string(string: *const c_char) -> ArvAcquisitionMode;
	pub fn arv_acquisition_mode_to_string(value: ArvAcquisitionMode) -> *const c_char;

	//=========================================================================
	// ArvAuto
	//=========================================================================
	pub fn arv_auto_get_type() -> GType;
	pub fn arv_auto_from_string(string: *const c_char) -> ArvAuto;
	pub fn arv_auto_to_string(value: ArvAuto) -> *const c_char;

	//=========================================================================
	// ArvBufferPayloadType
	//=========================================================================
	pub fn arv_buffer_payload_type_get_type() -> GType;

	//=========================================================================
	// ArvBufferStatus
	//=========================================================================
	pub fn arv_buffer_status_get_type() -> GType;

	//=========================================================================
	// ArvChunkParserError
	//=========================================================================
	pub fn arv_chunk_parser_error_get_type() -> GType;
	pub fn arv_chunk_parser_error_quark() -> glib::GQuark;

	//=========================================================================
	// ArvDeviceError
	//=========================================================================
	pub fn arv_device_error_get_type() -> GType;
	pub fn arv_device_error_quark() -> glib::GQuark;

	//=========================================================================
	// ArvDomNodeType
	//=========================================================================
	pub fn arv_dom_node_type_get_type() -> GType;

	//=========================================================================
	// ArvExposureMode
	//=========================================================================
	pub fn arv_exposure_mode_get_type() -> GType;
	pub fn arv_exposure_mode_from_string(string: *const c_char) -> ArvExposureMode;
	pub fn arv_exposure_mode_to_string(value: ArvExposureMode) -> *const c_char;

	//=========================================================================
	// ArvGcAccessMode
	//=========================================================================
	pub fn arv_gc_access_mode_get_type() -> GType;

	//=========================================================================
	// ArvGcCachable
	//=========================================================================
	pub fn arv_gc_cachable_get_type() -> GType;

	//=========================================================================
	// ArvGcDisplayNotation
	//=========================================================================
	pub fn arv_gc_display_notation_get_type() -> GType;

	//=========================================================================
	// ArvGcError
	//=========================================================================
	pub fn arv_gc_error_get_type() -> GType;
	pub fn arv_gc_error_quark() -> glib::GQuark;

	//=========================================================================
	// ArvGcIsLinear
	//=========================================================================
	pub fn arv_gc_is_linear_get_type() -> GType;

	//=========================================================================
	// ArvGcNameSpace
	//=========================================================================
	pub fn arv_gc_name_space_get_type() -> GType;

	//=========================================================================
	// ArvGcPropertyNodeType
	//=========================================================================
	pub fn arv_gc_property_node_type_get_type() -> GType;

	//=========================================================================
	// ArvGcRepresentation
	//=========================================================================
	pub fn arv_gc_representation_get_type() -> GType;

	//=========================================================================
	// ArvGcSignedness
	//=========================================================================
	pub fn arv_gc_signedness_get_type() -> GType;

	//=========================================================================
	// ArvGcStreamable
	//=========================================================================
	#[cfg(any(feature = "v0_8_8", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_8")))]
	pub fn arv_gc_streamable_get_type() -> GType;

	//=========================================================================
	// ArvGcVisibility
	//=========================================================================
	pub fn arv_gc_visibility_get_type() -> GType;

	//=========================================================================
	// ArvGvPacketSizeAdjustment
	//=========================================================================
	pub fn arv_gv_packet_size_adjustment_get_type() -> GType;

	//=========================================================================
	// ArvGvStreamOption
	//=========================================================================
	pub fn arv_gv_stream_option_get_type() -> GType;

	//=========================================================================
	// ArvGvStreamPacketResend
	//=========================================================================
	pub fn arv_gv_stream_packet_resend_get_type() -> GType;

	//=========================================================================
	// ArvGvStreamSocketBuffer
	//=========================================================================
	pub fn arv_gv_stream_socket_buffer_get_type() -> GType;

	//=========================================================================
	// ArvRangeCheckPolicy
	//=========================================================================
	#[cfg(any(feature = "v0_8_6", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_6")))]
	pub fn arv_range_check_policy_get_type() -> GType;

	//=========================================================================
	// ArvRegisterCachePolicy
	//=========================================================================
	pub fn arv_register_cache_policy_get_type() -> GType;

	//=========================================================================
	// ArvStreamCallbackType
	//=========================================================================
	pub fn arv_stream_callback_type_get_type() -> GType;

	//=========================================================================
	// ArvXmlSchemaError
	//=========================================================================
	pub fn arv_xml_schema_error_get_type() -> GType;
	pub fn arv_xml_schema_error_quark() -> glib::GQuark;

	//=========================================================================
	// ArvBuffer
	//=========================================================================
	pub fn arv_buffer_get_type() -> GType;
	pub fn arv_buffer_new(size: size_t, preallocated: *mut c_void) -> *mut ArvBuffer;
	pub fn arv_buffer_new_allocate(size: size_t) -> *mut ArvBuffer;
	pub fn arv_buffer_new_full(
		size: size_t,
		preallocated: *mut c_void,
		user_data: *mut c_void,
		user_data_destroy_func: glib::GDestroyNotify,
	) -> *mut ArvBuffer;
	pub fn arv_buffer_get_chunk_data(
		buffer: *mut ArvBuffer,
		chunk_id: u64,
		size: *mut size_t,
	) -> *mut u8;
	pub fn arv_buffer_get_data(buffer: *mut ArvBuffer, size: *mut size_t) -> *mut u8;
	pub fn arv_buffer_get_frame_id(buffer: *mut ArvBuffer) -> u64;
	pub fn arv_buffer_get_image_height(buffer: *mut ArvBuffer) -> c_int;
	pub fn arv_buffer_get_image_pixel_format(buffer: *mut ArvBuffer) -> ArvPixelFormat;
	pub fn arv_buffer_get_image_region(
		buffer: *mut ArvBuffer,
		x: *mut c_int,
		y: *mut c_int,
		width: *mut c_int,
		height: *mut c_int,
	);
	pub fn arv_buffer_get_image_width(buffer: *mut ArvBuffer) -> c_int;
	pub fn arv_buffer_get_image_x(buffer: *mut ArvBuffer) -> c_int;
	pub fn arv_buffer_get_image_y(buffer: *mut ArvBuffer) -> c_int;
	pub fn arv_buffer_get_payload_type(buffer: *mut ArvBuffer) -> ArvBufferPayloadType;
	pub fn arv_buffer_get_status(buffer: *mut ArvBuffer) -> ArvBufferStatus;
	pub fn arv_buffer_get_system_timestamp(buffer: *mut ArvBuffer) -> u64;
	pub fn arv_buffer_get_timestamp(buffer: *mut ArvBuffer) -> u64;
	pub fn arv_buffer_get_user_data(buffer: *mut ArvBuffer) -> *mut c_void;
	pub fn arv_buffer_has_chunks(buffer: *mut ArvBuffer) -> gboolean;
	#[cfg(any(feature = "v0_8_3", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_3")))]
	pub fn arv_buffer_set_frame_id(buffer: *mut ArvBuffer, frame_id: u64);
	pub fn arv_buffer_set_system_timestamp(buffer: *mut ArvBuffer, timestamp_ns: u64);
	pub fn arv_buffer_set_timestamp(buffer: *mut ArvBuffer, timestamp_ns: u64);

	//=========================================================================
	// ArvCamera
	//=========================================================================
	pub fn arv_camera_get_type() -> GType;
	pub fn arv_camera_new(name: *const c_char, error: *mut *mut glib::GError) -> *mut ArvCamera;
	#[cfg(any(feature = "v0_8_6", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_6")))]
	pub fn arv_camera_new_with_device(
		device: *mut ArvDevice,
		error: *mut *mut glib::GError,
	) -> *mut ArvCamera;
	pub fn arv_camera_abort_acquisition(camera: *mut ArvCamera, error: *mut *mut glib::GError);
	pub fn arv_camera_acquisition(
		camera: *mut ArvCamera,
		timeout: u64,
		error: *mut *mut glib::GError,
	) -> *mut ArvBuffer;
	#[cfg(any(feature = "v0_8_8", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_8")))]
	pub fn arv_camera_are_chunks_available(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_camera_clear_triggers(camera: *mut ArvCamera, error: *mut *mut glib::GError);
	pub fn arv_camera_create_chunk_parser(camera: *mut ArvCamera) -> *mut ArvChunkParser;
	pub fn arv_camera_create_stream(
		camera: *mut ArvCamera,
		callback: ArvStreamCallback,
		user_data: *mut c_void,
		error: *mut *mut glib::GError,
	) -> *mut ArvStream;
	pub fn arv_camera_dup_available_enumerations(
		camera: *mut ArvCamera,
		feature: *const c_char,
		n_values: *mut c_uint,
		error: *mut *mut glib::GError,
	) -> *mut i64;
	pub fn arv_camera_dup_available_enumerations_as_display_names(
		camera: *mut ArvCamera,
		feature: *const c_char,
		n_values: *mut c_uint,
		error: *mut *mut glib::GError,
	) -> *mut *const c_char;
	pub fn arv_camera_dup_available_enumerations_as_strings(
		camera: *mut ArvCamera,
		feature: *const c_char,
		n_values: *mut c_uint,
		error: *mut *mut glib::GError,
	) -> *mut *const c_char;
	pub fn arv_camera_dup_available_pixel_formats(
		camera: *mut ArvCamera,
		n_pixel_formats: *mut c_uint,
		error: *mut *mut glib::GError,
	) -> *mut i64;
	pub fn arv_camera_dup_available_pixel_formats_as_display_names(
		camera: *mut ArvCamera,
		n_pixel_formats: *mut c_uint,
		error: *mut *mut glib::GError,
	) -> *mut *const c_char;
	pub fn arv_camera_dup_available_pixel_formats_as_strings(
		camera: *mut ArvCamera,
		n_pixel_formats: *mut c_uint,
		error: *mut *mut glib::GError,
	) -> *mut *const c_char;
	pub fn arv_camera_dup_available_trigger_sources(
		camera: *mut ArvCamera,
		n_sources: *mut c_uint,
		error: *mut *mut glib::GError,
	) -> *mut *const c_char;
	pub fn arv_camera_dup_available_triggers(
		camera: *mut ArvCamera,
		n_triggers: *mut c_uint,
		error: *mut *mut glib::GError,
	) -> *mut *const c_char;
	pub fn arv_camera_execute_command(
		camera: *mut ArvCamera,
		feature: *const c_char,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_get_acquisition_mode(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> ArvAcquisitionMode;
	pub fn arv_camera_get_binning(
		camera: *mut ArvCamera,
		dx: *mut c_int,
		dy: *mut c_int,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_get_boolean(
		camera: *mut ArvCamera,
		feature: *const c_char,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_camera_get_boolean_gi(
		camera: *mut ArvCamera,
		feature: *const c_char,
		value: *mut gboolean,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_get_chunk_mode(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_camera_get_chunk_state(
		camera: *mut ArvCamera,
		chunk: *const c_char,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_camera_get_device(camera: *mut ArvCamera) -> *mut ArvDevice;
	pub fn arv_camera_get_device_id(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> *const c_char;
	#[cfg(any(feature = "v0_8_8", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_8")))]
	pub fn arv_camera_get_device_serial_number(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> *const c_char;
	pub fn arv_camera_get_exposure_time(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> c_double;
	pub fn arv_camera_get_exposure_time_auto(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> ArvAuto;
	pub fn arv_camera_get_exposure_time_bounds(
		camera: *mut ArvCamera,
		min: *mut c_double,
		max: *mut c_double,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_get_float(
		camera: *mut ArvCamera,
		feature: *const c_char,
		error: *mut *mut glib::GError,
	) -> c_double;
	pub fn arv_camera_get_float_bounds(
		camera: *mut ArvCamera,
		feature: *const c_char,
		min: *mut c_double,
		max: *mut c_double,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_get_frame_count(camera: *mut ArvCamera, error: *mut *mut glib::GError)
		-> i64;
	pub fn arv_camera_get_frame_count_bounds(
		camera: *mut ArvCamera,
		min: *mut i64,
		max: *mut i64,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_get_frame_rate(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> c_double;
	pub fn arv_camera_get_frame_rate_bounds(
		camera: *mut ArvCamera,
		min: *mut c_double,
		max: *mut c_double,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_get_gain(camera: *mut ArvCamera, error: *mut *mut glib::GError) -> c_double;
	pub fn arv_camera_get_gain_auto(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> ArvAuto;
	pub fn arv_camera_get_gain_bounds(
		camera: *mut ArvCamera,
		min: *mut c_double,
		max: *mut c_double,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_get_height_bounds(
		camera: *mut ArvCamera,
		min: *mut c_int,
		max: *mut c_int,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_get_height_increment(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> c_int;
	pub fn arv_camera_get_integer(
		camera: *mut ArvCamera,
		feature: *const c_char,
		error: *mut *mut glib::GError,
	) -> i64;
	pub fn arv_camera_get_integer_bounds(
		camera: *mut ArvCamera,
		feature: *const c_char,
		min: *mut i64,
		max: *mut i64,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_get_integer_increment(
		camera: *mut ArvCamera,
		feature: *const c_char,
		error: *mut *mut glib::GError,
	) -> i64;
	pub fn arv_camera_get_model_name(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> *const c_char;
	pub fn arv_camera_get_payload(camera: *mut ArvCamera, error: *mut *mut glib::GError) -> c_uint;
	pub fn arv_camera_get_pixel_format(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> ArvPixelFormat;
	pub fn arv_camera_get_pixel_format_as_string(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> *const c_char;
	pub fn arv_camera_get_region(
		camera: *mut ArvCamera,
		x: *mut c_int,
		y: *mut c_int,
		width: *mut c_int,
		height: *mut c_int,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_get_sensor_size(
		camera: *mut ArvCamera,
		width: *mut c_int,
		height: *mut c_int,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_get_string(
		camera: *mut ArvCamera,
		feature: *const c_char,
		error: *mut *mut glib::GError,
	) -> *const c_char;
	pub fn arv_camera_get_trigger_source(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> *const c_char;
	pub fn arv_camera_get_vendor_name(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> *const c_char;
	pub fn arv_camera_get_width_bounds(
		camera: *mut ArvCamera,
		min: *mut c_int,
		max: *mut c_int,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_get_width_increment(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> c_int;
	pub fn arv_camera_get_x_binning_bounds(
		camera: *mut ArvCamera,
		min: *mut c_int,
		max: *mut c_int,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_get_x_binning_increment(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> c_int;
	pub fn arv_camera_get_x_offset_bounds(
		camera: *mut ArvCamera,
		min: *mut c_int,
		max: *mut c_int,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_get_x_offset_increment(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> c_int;
	pub fn arv_camera_get_y_binning_bounds(
		camera: *mut ArvCamera,
		min: *mut c_int,
		max: *mut c_int,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_get_y_binning_increment(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> c_int;
	pub fn arv_camera_get_y_offset_bounds(
		camera: *mut ArvCamera,
		min: *mut c_int,
		max: *mut c_int,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_get_y_offset_increment(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> c_int;
	pub fn arv_camera_gv_auto_packet_size(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> c_uint;
	pub fn arv_camera_gv_get_current_stream_channel(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> c_int;
	pub fn arv_camera_gv_get_n_stream_channels(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> c_int;
	pub fn arv_camera_gv_get_packet_delay(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> i64;
	pub fn arv_camera_gv_get_packet_size(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> c_uint;
	pub fn arv_camera_gv_select_stream_channel(
		camera: *mut ArvCamera,
		channel_id: c_int,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_gv_set_packet_delay(
		camera: *mut ArvCamera,
		delay_ns: i64,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_gv_set_packet_size(
		camera: *mut ArvCamera,
		packet_size: c_int,
		error: *mut *mut glib::GError,
	);
	#[cfg(any(feature = "v0_8_3", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_3")))]
	pub fn arv_camera_gv_set_packet_size_adjustment(
		camera: *mut ArvCamera,
		adjustment: ArvGvPacketSizeAdjustment,
	);
	pub fn arv_camera_gv_set_stream_options(camera: *mut ArvCamera, options: ArvGvStreamOption);
	pub fn arv_camera_is_binning_available(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_camera_is_exposure_auto_available(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_camera_is_exposure_time_available(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_camera_is_feature_available(
		camera: *mut ArvCamera,
		feature: *const c_char,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_camera_is_frame_rate_available(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_camera_is_gain_auto_available(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_camera_is_gain_available(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_camera_is_gv_device(camera: *mut ArvCamera) -> gboolean;
	pub fn arv_camera_is_uv_device(camera: *mut ArvCamera) -> gboolean;
	pub fn arv_camera_set_acquisition_mode(
		camera: *mut ArvCamera,
		value: ArvAcquisitionMode,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_binning(
		camera: *mut ArvCamera,
		dx: c_int,
		dy: c_int,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_boolean(
		camera: *mut ArvCamera,
		feature: *const c_char,
		value: gboolean,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_chunk_mode(
		camera: *mut ArvCamera,
		is_active: gboolean,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_chunk_state(
		camera: *mut ArvCamera,
		chunk: *const c_char,
		is_enabled: gboolean,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_chunks(
		camera: *mut ArvCamera,
		chunk_list: *const c_char,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_exposure_mode(
		camera: *mut ArvCamera,
		mode: ArvExposureMode,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_exposure_time(
		camera: *mut ArvCamera,
		exposure_time_us: c_double,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_exposure_time_auto(
		camera: *mut ArvCamera,
		auto_mode: ArvAuto,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_float(
		camera: *mut ArvCamera,
		feature: *const c_char,
		value: c_double,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_frame_count(
		camera: *mut ArvCamera,
		frame_count: i64,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_frame_rate(
		camera: *mut ArvCamera,
		frame_rate: c_double,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_gain(
		camera: *mut ArvCamera,
		gain: c_double,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_gain_auto(
		camera: *mut ArvCamera,
		auto_mode: ArvAuto,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_integer(
		camera: *mut ArvCamera,
		feature: *const c_char,
		value: i64,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_pixel_format(
		camera: *mut ArvCamera,
		format: ArvPixelFormat,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_pixel_format_from_string(
		camera: *mut ArvCamera,
		format: *const c_char,
		error: *mut *mut glib::GError,
	);
	#[cfg(any(feature = "v0_8_8", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_8")))]
	pub fn arv_camera_set_range_check_policy(camera: *mut ArvCamera, policy: ArvRangeCheckPolicy);
	pub fn arv_camera_set_region(
		camera: *mut ArvCamera,
		x: c_int,
		y: c_int,
		width: c_int,
		height: c_int,
		error: *mut *mut glib::GError,
	);
	#[cfg(any(feature = "v0_8_8", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_8")))]
	pub fn arv_camera_set_register_cache_policy(
		camera: *mut ArvCamera,
		policy: ArvRegisterCachePolicy,
	);
	pub fn arv_camera_set_string(
		camera: *mut ArvCamera,
		feature: *const c_char,
		value: *const c_char,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_trigger(
		camera: *mut ArvCamera,
		source: *const c_char,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_set_trigger_source(
		camera: *mut ArvCamera,
		source: *const c_char,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_software_trigger(camera: *mut ArvCamera, error: *mut *mut glib::GError);
	pub fn arv_camera_start_acquisition(camera: *mut ArvCamera, error: *mut *mut glib::GError);
	pub fn arv_camera_stop_acquisition(camera: *mut ArvCamera, error: *mut *mut glib::GError);
	pub fn arv_camera_uv_get_bandwidth(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> c_uint;
	pub fn arv_camera_uv_get_bandwidth_bounds(
		camera: *mut ArvCamera,
		min: *mut c_uint,
		max: *mut c_uint,
		error: *mut *mut glib::GError,
	);
	pub fn arv_camera_uv_is_bandwidth_control_available(
		camera: *mut ArvCamera,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_camera_uv_set_bandwidth(
		camera: *mut ArvCamera,
		bandwidth: c_uint,
		error: *mut *mut glib::GError,
	);

	//=========================================================================
	// ArvChunkParser
	//=========================================================================
	pub fn arv_chunk_parser_get_type() -> GType;
	pub fn arv_chunk_parser_new(xml: *const c_char, size: size_t) -> *mut ArvChunkParser;
	pub fn arv_chunk_parser_get_boolean_value(
		parser: *mut ArvChunkParser,
		buffer: *mut ArvBuffer,
		chunk: *const c_char,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_chunk_parser_get_float_value(
		parser: *mut ArvChunkParser,
		buffer: *mut ArvBuffer,
		chunk: *const c_char,
		error: *mut *mut glib::GError,
	) -> c_double;
	pub fn arv_chunk_parser_get_integer_value(
		parser: *mut ArvChunkParser,
		buffer: *mut ArvBuffer,
		chunk: *const c_char,
		error: *mut *mut glib::GError,
	) -> i64;
	pub fn arv_chunk_parser_get_string_value(
		parser: *mut ArvChunkParser,
		buffer: *mut ArvBuffer,
		chunk: *const c_char,
		error: *mut *mut glib::GError,
	) -> *const c_char;

	//=========================================================================
	// ArvDevice
	//=========================================================================
	pub fn arv_device_get_type() -> GType;
	pub fn arv_device_create_chunk_parser(device: *mut ArvDevice) -> *mut ArvChunkParser;
	pub fn arv_device_create_stream(
		device: *mut ArvDevice,
		callback: ArvStreamCallback,
		user_data: *mut c_void,
		error: *mut *mut glib::GError,
	) -> *mut ArvStream;
	pub fn arv_device_dup_available_enumeration_feature_values(
		device: *mut ArvDevice,
		feature: *const c_char,
		n_values: *mut c_uint,
		error: *mut *mut glib::GError,
	) -> *mut i64;
	pub fn arv_device_dup_available_enumeration_feature_values_as_display_names(
		device: *mut ArvDevice,
		feature: *const c_char,
		n_values: *mut c_uint,
		error: *mut *mut glib::GError,
	) -> *mut *const c_char;
	pub fn arv_device_dup_available_enumeration_feature_values_as_strings(
		device: *mut ArvDevice,
		feature: *const c_char,
		n_values: *mut c_uint,
		error: *mut *mut glib::GError,
	) -> *mut *const c_char;
	pub fn arv_device_execute_command(
		device: *mut ArvDevice,
		feature: *const c_char,
		error: *mut *mut glib::GError,
	);
	pub fn arv_device_get_boolean_feature_value(
		device: *mut ArvDevice,
		feature: *const c_char,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_device_get_boolean_feature_value_gi(
		device: *mut ArvDevice,
		feature: *const c_char,
		value: *mut gboolean,
		error: *mut *mut glib::GError,
	);
	pub fn arv_device_get_feature(device: *mut ArvDevice, feature: *const c_char)
		-> *mut ArvGcNode;
	pub fn arv_device_get_float_feature_bounds(
		device: *mut ArvDevice,
		feature: *const c_char,
		min: *mut c_double,
		max: *mut c_double,
		error: *mut *mut glib::GError,
	);
	pub fn arv_device_get_float_feature_value(
		device: *mut ArvDevice,
		feature: *const c_char,
		error: *mut *mut glib::GError,
	) -> c_double;
	pub fn arv_device_get_genicam(device: *mut ArvDevice) -> *mut ArvGc;
	pub fn arv_device_get_genicam_xml(device: *mut ArvDevice, size: *mut size_t) -> *const c_char;
	pub fn arv_device_get_integer_feature_bounds(
		device: *mut ArvDevice,
		feature: *const c_char,
		min: *mut i64,
		max: *mut i64,
		error: *mut *mut glib::GError,
	);
	pub fn arv_device_get_integer_feature_increment(
		device: *mut ArvDevice,
		feature: *const c_char,
		error: *mut *mut glib::GError,
	) -> i64;
	pub fn arv_device_get_integer_feature_value(
		device: *mut ArvDevice,
		feature: *const c_char,
		error: *mut *mut glib::GError,
	) -> i64;
	pub fn arv_device_get_string_feature_value(
		device: *mut ArvDevice,
		feature: *const c_char,
		error: *mut *mut glib::GError,
	) -> *const c_char;
	pub fn arv_device_is_feature_available(
		device: *mut ArvDevice,
		feature: *const c_char,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_device_read_memory(
		device: *mut ArvDevice,
		address: u64,
		size: u32,
		buffer: *mut c_void,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_device_read_register(
		device: *mut ArvDevice,
		address: u64,
		value: *mut u32,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_device_set_boolean_feature_value(
		device: *mut ArvDevice,
		feature: *const c_char,
		value: gboolean,
		error: *mut *mut glib::GError,
	);
	pub fn arv_device_set_features_from_string(
		device: *mut ArvDevice,
		string: *const c_char,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_device_set_float_feature_value(
		device: *mut ArvDevice,
		feature: *const c_char,
		value: c_double,
		error: *mut *mut glib::GError,
	);
	pub fn arv_device_set_integer_feature_value(
		device: *mut ArvDevice,
		feature: *const c_char,
		value: i64,
		error: *mut *mut glib::GError,
	);
	#[cfg(any(feature = "v0_8_6", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_6")))]
	pub fn arv_device_set_range_check_policy(device: *mut ArvDevice, policy: ArvRangeCheckPolicy);
	pub fn arv_device_set_register_cache_policy(
		device: *mut ArvDevice,
		policy: ArvRegisterCachePolicy,
	);
	pub fn arv_device_set_string_feature_value(
		device: *mut ArvDevice,
		feature: *const c_char,
		value: *const c_char,
		error: *mut *mut glib::GError,
	);
	pub fn arv_device_write_memory(
		device: *mut ArvDevice,
		address: u64,
		size: u32,
		buffer: *mut c_void,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_device_write_register(
		device: *mut ArvDevice,
		address: u64,
		value: u32,
		error: *mut *mut glib::GError,
	) -> gboolean;

	//=========================================================================
	// ArvDomCharacterData
	//=========================================================================
	pub fn arv_dom_character_data_get_type() -> GType;
	pub fn arv_dom_character_data_get_data(self_: *mut ArvDomCharacterData) -> *const c_char;
	pub fn arv_dom_character_data_set_data(self_: *mut ArvDomCharacterData, value: *const c_char);

	//=========================================================================
	// ArvDomDocument
	//=========================================================================
	pub fn arv_dom_document_get_type() -> GType;
	pub fn arv_dom_document_new_from_memory(
		buffer: *mut c_void,
		size: c_int,
		error: *mut *mut glib::GError,
	) -> *mut ArvDomDocument;
	pub fn arv_dom_document_new_from_path(
		path: *const c_char,
		error: *mut *mut glib::GError,
	) -> *mut ArvDomDocument;
	pub fn arv_dom_document_new_from_url(
		url: *const c_char,
		error: *mut *mut glib::GError,
	) -> *mut ArvDomDocument;
	pub fn arv_dom_document_append_from_memory(
		document: *mut ArvDomDocument,
		node: *mut ArvDomNode,
		buffer: *mut c_void,
		size: c_int,
		error: *mut *mut glib::GError,
	);
	pub fn arv_dom_document_create_element(
		self_: *mut ArvDomDocument,
		tag_name: *const c_char,
	) -> *mut ArvDomElement;
	pub fn arv_dom_document_create_text_node(
		self_: *mut ArvDomDocument,
		data: *const c_char,
	) -> *mut ArvDomText;
	pub fn arv_dom_document_get_document_element(self_: *mut ArvDomDocument) -> *mut ArvDomElement;
	pub fn arv_dom_document_get_href_data(
		self_: *mut ArvDomDocument,
		href: *const c_char,
		size: *mut size_t,
	) -> *mut c_void;
	pub fn arv_dom_document_get_url(self_: *mut ArvDomDocument) -> *const c_char;
	pub fn arv_dom_document_set_path(self_: *mut ArvDomDocument, path: *const c_char);
	pub fn arv_dom_document_set_url(self_: *mut ArvDomDocument, url: *const c_char);

	//=========================================================================
	// ArvDomDocumentFragment
	//=========================================================================
	pub fn arv_dom_document_fragment_get_type() -> GType;
	pub fn arv_dom_document_fragment_new() -> *mut ArvDomDocumentFragment;

	//=========================================================================
	// ArvDomElement
	//=========================================================================
	pub fn arv_dom_element_get_type() -> GType;
	pub fn arv_dom_element_get_attribute(
		self_: *mut ArvDomElement,
		name: *const c_char,
	) -> *const c_char;
	pub fn arv_dom_element_get_tag_name(self_: *mut ArvDomElement) -> *const c_char;
	pub fn arv_dom_element_set_attribute(
		self_: *mut ArvDomElement,
		name: *const c_char,
		attribute_value: *const c_char,
	);

	//=========================================================================
	// ArvDomNamedNodeMap
	//=========================================================================
	pub fn arv_dom_named_node_map_get_type() -> GType;
	pub fn arv_dom_named_node_map_get_item(
		map: *mut ArvDomNamedNodeMap,
		index: c_uint,
	) -> *mut ArvDomNode;
	pub fn arv_dom_named_node_map_get_length(map: *mut ArvDomNamedNodeMap) -> c_uint;
	pub fn arv_dom_named_node_map_get_named_item(
		map: *mut ArvDomNamedNodeMap,
		name: *const c_char,
	) -> *mut ArvDomNode;
	pub fn arv_dom_named_node_map_remove_named_item(
		map: *mut ArvDomNamedNodeMap,
		name: *const c_char,
	) -> *mut ArvDomNode;
	pub fn arv_dom_named_node_map_set_named_item(
		map: *mut ArvDomNamedNodeMap,
		item: *mut ArvDomNode,
	) -> *mut ArvDomNode;

	//=========================================================================
	// ArvDomNode
	//=========================================================================
	pub fn arv_dom_node_get_type() -> GType;
	pub fn arv_dom_node_append_child(
		self_: *mut ArvDomNode,
		new_child: *mut ArvDomNode,
	) -> *mut ArvDomNode;
	pub fn arv_dom_node_changed(self_: *mut ArvDomNode);
	pub fn arv_dom_node_get_child_nodes(self_: *mut ArvDomNode) -> *mut ArvDomNodeList;
	pub fn arv_dom_node_get_first_child(self_: *mut ArvDomNode) -> *mut ArvDomNode;
	pub fn arv_dom_node_get_last_child(self_: *mut ArvDomNode) -> *mut ArvDomNode;
	pub fn arv_dom_node_get_next_sibling(self_: *mut ArvDomNode) -> *mut ArvDomNode;
	pub fn arv_dom_node_get_node_name(self_: *mut ArvDomNode) -> *const c_char;
	pub fn arv_dom_node_get_node_type(self_: *mut ArvDomNode) -> ArvDomNodeType;
	pub fn arv_dom_node_get_node_value(self_: *mut ArvDomNode) -> *const c_char;
	pub fn arv_dom_node_get_owner_document(self_: *mut ArvDomNode) -> *mut ArvDomDocument;
	pub fn arv_dom_node_get_parent_node(self_: *mut ArvDomNode) -> *mut ArvDomNode;
	pub fn arv_dom_node_get_previous_sibling(self_: *mut ArvDomNode) -> *mut ArvDomNode;
	pub fn arv_dom_node_has_child_nodes(self_: *mut ArvDomNode) -> gboolean;
	pub fn arv_dom_node_insert_before(
		self_: *mut ArvDomNode,
		new_child: *mut ArvDomNode,
		ref_child: *mut ArvDomNode,
	) -> *mut ArvDomNode;
	pub fn arv_dom_node_remove_child(
		self_: *mut ArvDomNode,
		old_child: *mut ArvDomNode,
	) -> *mut ArvDomNode;
	pub fn arv_dom_node_replace_child(
		self_: *mut ArvDomNode,
		new_child: *mut ArvDomNode,
		old_child: *mut ArvDomNode,
	) -> *mut ArvDomNode;
	pub fn arv_dom_node_set_node_value(self_: *mut ArvDomNode, new_value: *const c_char);

	//=========================================================================
	// ArvDomNodeChildList
	//=========================================================================
	pub fn arv_dom_node_child_list_get_type() -> GType;
	pub fn arv_dom_node_child_list_new(parent_node: *mut ArvDomNode) -> *mut ArvDomNodeList;

	//=========================================================================
	// ArvDomNodeList
	//=========================================================================
	pub fn arv_dom_node_list_get_type() -> GType;
	pub fn arv_dom_node_list_get_item(list: *mut ArvDomNodeList, index: c_uint) -> *mut ArvDomNode;
	pub fn arv_dom_node_list_get_length(list: *mut ArvDomNodeList) -> c_uint;

	//=========================================================================
	// ArvDomText
	//=========================================================================
	pub fn arv_dom_text_get_type() -> GType;
	pub fn arv_dom_text_new(data: *const c_char) -> *mut ArvDomNode;

	//=========================================================================
	// ArvEvaluator
	//=========================================================================
	pub fn arv_evaluator_get_type() -> GType;
	pub fn arv_evaluator_new(expression: *const c_char) -> *mut ArvEvaluator;
	pub fn arv_evaluator_evaluate_as_double(
		evaluator: *mut ArvEvaluator,
		error: *mut *mut glib::GError,
	) -> c_double;
	pub fn arv_evaluator_evaluate_as_int64(
		evaluator: *mut ArvEvaluator,
		error: *mut *mut glib::GError,
	) -> i64;
	pub fn arv_evaluator_get_constant(
		evaluator: *mut ArvEvaluator,
		name: *const c_char,
	) -> *const c_char;
	pub fn arv_evaluator_get_expression(evaluator: *mut ArvEvaluator) -> *const c_char;
	pub fn arv_evaluator_get_sub_expression(
		evaluator: *mut ArvEvaluator,
		name: *const c_char,
	) -> *const c_char;
	pub fn arv_evaluator_set_constant(
		evaluator: *mut ArvEvaluator,
		name: *const c_char,
		constant: *const c_char,
	);
	pub fn arv_evaluator_set_double_variable(
		evaluator: *mut ArvEvaluator,
		name: *const c_char,
		v_double: c_double,
	);
	pub fn arv_evaluator_set_expression(evaluator: *mut ArvEvaluator, expression: *const c_char);
	pub fn arv_evaluator_set_int64_variable(
		evaluator: *mut ArvEvaluator,
		name: *const c_char,
		v_int64: i64,
	);
	pub fn arv_evaluator_set_sub_expression(
		evaluator: *mut ArvEvaluator,
		name: *const c_char,
		expression: *const c_char,
	);

	//=========================================================================
	// ArvFakeCamera
	//=========================================================================
	pub fn arv_fake_camera_get_type() -> GType;
	pub fn arv_fake_camera_new(serial_number: *const c_char) -> *mut ArvFakeCamera;
	pub fn arv_fake_camera_new_full(
		serial_number: *const c_char,
		genicam_filename: *const c_char,
	) -> *mut ArvFakeCamera;
	pub fn arv_fake_camera_fill_buffer(
		camera: *mut ArvFakeCamera,
		buffer: *mut ArvBuffer,
		packet_size: *mut u32,
	);
	pub fn arv_fake_camera_get_acquisition_status(camera: *mut ArvFakeCamera) -> u32;
	pub fn arv_fake_camera_get_control_channel_privilege(camera: *mut ArvFakeCamera) -> u32;
	pub fn arv_fake_camera_get_genicam_xml(
		camera: *mut ArvFakeCamera,
		size: *mut size_t,
	) -> *const c_char;
	pub fn arv_fake_camera_get_heartbeat_timeout(camera: *mut ArvFakeCamera) -> u32;
	pub fn arv_fake_camera_get_payload(camera: *mut ArvFakeCamera) -> size_t;
	pub fn arv_fake_camera_get_sleep_time_for_next_frame(
		camera: *mut ArvFakeCamera,
		next_timestamp_us: *mut u64,
	) -> u64;
	pub fn arv_fake_camera_get_stream_address(
		camera: *mut ArvFakeCamera,
	) -> *mut gio::GSocketAddress;
	pub fn arv_fake_camera_read_memory(
		camera: *mut ArvFakeCamera,
		address: u32,
		size: u32,
		buffer: *mut c_void,
	) -> gboolean;
	pub fn arv_fake_camera_read_register(
		camera: *mut ArvFakeCamera,
		address: u32,
		value: *mut u32,
	) -> gboolean;
	pub fn arv_fake_camera_set_control_channel_privilege(
		camera: *mut ArvFakeCamera,
		privilege: u32,
	);
	pub fn arv_fake_camera_set_fill_pattern(
		camera: *mut ArvFakeCamera,
		fill_pattern_callback: ArvFakeCameraFillPattern,
		fill_pattern_data: *mut c_void,
	);
	pub fn arv_fake_camera_set_inet_address(
		camera: *mut ArvFakeCamera,
		address: *mut gio::GInetAddress,
	);
	pub fn arv_fake_camera_set_trigger_frequency(camera: *mut ArvFakeCamera, frequency: c_double);
	pub fn arv_fake_camera_wait_for_next_frame(camera: *mut ArvFakeCamera);
	pub fn arv_fake_camera_write_memory(
		camera: *mut ArvFakeCamera,
		address: u32,
		size: u32,
		buffer: *mut c_void,
	) -> gboolean;
	pub fn arv_fake_camera_write_register(
		camera: *mut ArvFakeCamera,
		address: u32,
		value: u32,
	) -> gboolean;

	//=========================================================================
	// ArvFakeDevice
	//=========================================================================
	pub fn arv_fake_device_get_type() -> GType;
	pub fn arv_fake_device_new(
		serial_number: *const c_char,
		error: *mut *mut glib::GError,
	) -> *mut ArvDevice;
	pub fn arv_fake_device_get_fake_camera(device: *mut ArvFakeDevice) -> *mut ArvFakeCamera;

	//=========================================================================
	// ArvFakeInterface
	//=========================================================================
	pub fn arv_fake_interface_get_type() -> GType;
	pub fn arv_fake_interface_get_instance() -> *mut ArvInterface;

	//=========================================================================
	// ArvFakeStream
	//=========================================================================
	pub fn arv_fake_stream_get_type() -> GType;

	//=========================================================================
	// ArvGc
	//=========================================================================
	pub fn arv_gc_get_type() -> GType;
	pub fn arv_gc_new(device: *mut ArvDevice, xml: *mut c_void, size: size_t) -> *mut ArvGc;
	pub fn arv_gc_p_value_indexed_node_new() -> *mut ArvGcNode;
	pub fn arv_gc_invalidator_has_changed(self_: *mut ArvGcInvalidatorNode) -> gboolean;
	pub fn arv_gc_get_buffer(genicam: *mut ArvGc) -> *mut ArvBuffer;
	pub fn arv_gc_get_device(genicam: *mut ArvGc) -> *mut ArvDevice;
	pub fn arv_gc_get_node(genicam: *mut ArvGc, name: *const c_char) -> *mut ArvGcNode;
	#[cfg(any(feature = "v0_8_6", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_6")))]
	pub fn arv_gc_get_range_check_policy(genicam: *mut ArvGc) -> ArvRangeCheckPolicy;
	pub fn arv_gc_get_register_cache_policy(genicam: *mut ArvGc) -> ArvRegisterCachePolicy;
	pub fn arv_gc_register_feature_node(genicam: *mut ArvGc, node: *mut ArvGcFeatureNode);
	pub fn arv_gc_set_buffer(genicam: *mut ArvGc, buffer: *mut ArvBuffer);
	pub fn arv_gc_set_default_node_data(genicam: *mut ArvGc, node_name: *const c_char, ...);
	#[cfg(any(feature = "v0_8_6", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_6")))]
	pub fn arv_gc_set_range_check_policy(genicam: *mut ArvGc, policy: ArvRangeCheckPolicy);
	pub fn arv_gc_set_register_cache_policy(genicam: *mut ArvGc, policy: ArvRegisterCachePolicy);

	//=========================================================================
	// ArvGcBoolean
	//=========================================================================
	pub fn arv_gc_boolean_get_type() -> GType;
	pub fn arv_gc_boolean_new() -> *mut ArvGcNode;
	pub fn arv_gc_boolean_get_value(
		gc_boolean: *mut ArvGcBoolean,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_gc_boolean_get_value_gi(
		gc_boolean: *mut ArvGcBoolean,
		value: *mut gboolean,
		error: *mut *mut glib::GError,
	);
	pub fn arv_gc_boolean_set_value(
		gc_boolean: *mut ArvGcBoolean,
		v_boolean: gboolean,
		error: *mut *mut glib::GError,
	);

	//=========================================================================
	// ArvGcCategory
	//=========================================================================
	pub fn arv_gc_category_get_type() -> GType;
	pub fn arv_gc_category_new() -> *mut ArvGcNode;
	pub fn arv_gc_category_get_features(category: *mut ArvGcCategory) -> *const glib::GSList;

	//=========================================================================
	// ArvGcCommand
	//=========================================================================
	pub fn arv_gc_command_get_type() -> GType;
	pub fn arv_gc_command_new() -> *mut ArvGcNode;
	pub fn arv_gc_command_execute(gc_command: *mut ArvGcCommand, error: *mut *mut glib::GError);

	//=========================================================================
	// ArvGcConverter
	//=========================================================================
	pub fn arv_gc_converter_get_type() -> GType;

	//=========================================================================
	// ArvGcConverterNode
	//=========================================================================
	pub fn arv_gc_converter_node_get_type() -> GType;
	pub fn arv_gc_converter_node_new() -> *mut ArvGcNode;

	//=========================================================================
	// ArvGcEnumEntry
	//=========================================================================
	pub fn arv_gc_enum_entry_get_type() -> GType;
	pub fn arv_gc_enum_entry_new() -> *mut ArvGcNode;
	pub fn arv_gc_enum_entry_get_value(
		entry: *mut ArvGcEnumEntry,
		error: *mut *mut glib::GError,
	) -> i64;

	//=========================================================================
	// ArvGcEnumeration
	//=========================================================================
	pub fn arv_gc_enumeration_get_type() -> GType;
	pub fn arv_gc_enumeration_new() -> *mut ArvGcNode;
	pub fn arv_gc_enumeration_dup_available_display_names(
		enumeration: *mut ArvGcEnumeration,
		n_values: *mut c_uint,
		error: *mut *mut glib::GError,
	) -> *mut *const c_char;
	pub fn arv_gc_enumeration_dup_available_int_values(
		enumeration: *mut ArvGcEnumeration,
		n_values: *mut c_uint,
		error: *mut *mut glib::GError,
	) -> *mut i64;
	pub fn arv_gc_enumeration_dup_available_string_values(
		enumeration: *mut ArvGcEnumeration,
		n_values: *mut c_uint,
		error: *mut *mut glib::GError,
	) -> *mut *const c_char;
	pub fn arv_gc_enumeration_get_entries(
		enumeration: *mut ArvGcEnumeration,
	) -> *const glib::GSList;
	pub fn arv_gc_enumeration_get_int_value(
		enumeration: *mut ArvGcEnumeration,
		error: *mut *mut glib::GError,
	) -> i64;
	pub fn arv_gc_enumeration_get_string_value(
		enumeration: *mut ArvGcEnumeration,
		error: *mut *mut glib::GError,
	) -> *const c_char;
	pub fn arv_gc_enumeration_set_int_value(
		enumeration: *mut ArvGcEnumeration,
		value: i64,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_gc_enumeration_set_string_value(
		enumeration: *mut ArvGcEnumeration,
		value: *const c_char,
		error: *mut *mut glib::GError,
	) -> gboolean;

	//=========================================================================
	// ArvGcFeatureNode
	//=========================================================================
	pub fn arv_gc_feature_node_get_type() -> GType;
	pub fn arv_gc_feature_node_get_actual_access_mode(
		gc_feature_node: *mut ArvGcFeatureNode,
	) -> ArvGcAccessMode;
	pub fn arv_gc_feature_node_get_description(
		gc_feature_node: *mut ArvGcFeatureNode,
	) -> *const c_char;
	pub fn arv_gc_feature_node_get_display_name(
		gc_feature_node: *mut ArvGcFeatureNode,
	) -> *const c_char;
	pub fn arv_gc_feature_node_get_imposed_access_mode(
		gc_feature_node: *mut ArvGcFeatureNode,
	) -> ArvGcAccessMode;
	pub fn arv_gc_feature_node_get_name(gc_feature_node: *mut ArvGcFeatureNode) -> *const c_char;
	pub fn arv_gc_feature_node_get_name_space(
		gc_feature_node: *mut ArvGcFeatureNode,
	) -> ArvGcNameSpace;
	pub fn arv_gc_feature_node_get_tooltip(gc_feature_node: *mut ArvGcFeatureNode)
		-> *const c_char;
	pub fn arv_gc_feature_node_get_value_as_string(
		gc_feature_node: *mut ArvGcFeatureNode,
		error: *mut *mut glib::GError,
	) -> *const c_char;
	pub fn arv_gc_feature_node_get_visibility(
		gc_feature_node: *mut ArvGcFeatureNode,
	) -> ArvGcVisibility;
	pub fn arv_gc_feature_node_is_available(
		gc_feature_node: *mut ArvGcFeatureNode,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_gc_feature_node_is_implemented(
		gc_feature_node: *mut ArvGcFeatureNode,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_gc_feature_node_is_locked(
		gc_feature_node: *mut ArvGcFeatureNode,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_gc_feature_node_set_value_from_string(
		gc_feature_node: *mut ArvGcFeatureNode,
		string: *const c_char,
		error: *mut *mut glib::GError,
	);

	//=========================================================================
	// ArvGcFloatNode
	//=========================================================================
	pub fn arv_gc_float_node_get_type() -> GType;
	pub fn arv_gc_float_node_new() -> *mut ArvGcNode;

	//=========================================================================
	// ArvGcFloatRegNode
	//=========================================================================
	pub fn arv_gc_float_reg_node_get_type() -> GType;
	pub fn arv_gc_float_reg_node_new() -> *mut ArvGcNode;

	//=========================================================================
	// ArvGcGroupNode
	//=========================================================================
	pub fn arv_gc_group_node_get_type() -> GType;
	pub fn arv_gc_group_node_new() -> *mut ArvGcNode;

	//=========================================================================
	// ArvGcIndexNode
	//=========================================================================
	pub fn arv_gc_index_node_get_type() -> GType;
	pub fn arv_gc_index_node_new() -> *mut ArvGcNode;
	pub fn arv_gc_index_node_get_index(
		index_node: *mut ArvGcIndexNode,
		default_offset: i64,
		error: *mut *mut glib::GError,
	) -> i64;

	//=========================================================================
	// ArvGcIntConverterNode
	//=========================================================================
	pub fn arv_gc_int_converter_node_get_type() -> GType;
	pub fn arv_gc_int_converter_node_new() -> *mut ArvGcNode;

	//=========================================================================
	// ArvGcIntRegNode
	//=========================================================================
	pub fn arv_gc_int_reg_node_get_type() -> GType;
	pub fn arv_gc_int_reg_node_new() -> *mut ArvGcNode;

	//=========================================================================
	// ArvGcIntSwissKnifeNode
	//=========================================================================
	pub fn arv_gc_int_swiss_knife_node_get_type() -> GType;
	pub fn arv_gc_int_swiss_knife_node_new() -> *mut ArvGcNode;

	//=========================================================================
	// ArvGcIntegerNode
	//=========================================================================
	pub fn arv_gc_integer_node_get_type() -> GType;
	pub fn arv_gc_integer_node_new() -> *mut ArvGcNode;

	//=========================================================================
	// ArvGcInvalidatorNode
	//=========================================================================
	pub fn arv_gc_invalidator_node_get_type() -> GType;
	pub fn arv_gc_invalidator_node_new() -> *mut ArvGcNode;

	//=========================================================================
	// ArvGcMaskedIntRegNode
	//=========================================================================
	pub fn arv_gc_masked_int_reg_node_get_type() -> GType;
	pub fn arv_gc_masked_int_reg_node_new() -> *mut ArvGcNode;

	//=========================================================================
	// ArvGcNode
	//=========================================================================
	pub fn arv_gc_node_get_type() -> GType;
	pub fn arv_gc_node_get_genicam(gc_node: *mut ArvGcNode) -> *mut ArvGc;

	//=========================================================================
	// ArvGcPort
	//=========================================================================
	pub fn arv_gc_port_get_type() -> GType;
	pub fn arv_gc_port_new() -> *mut ArvGcNode;
	pub fn arv_gc_port_read(
		port: *mut ArvGcPort,
		buffer: *mut c_void,
		address: u64,
		length: u64,
		error: *mut *mut glib::GError,
	);
	pub fn arv_gc_port_write(
		port: *mut ArvGcPort,
		buffer: *mut c_void,
		address: u64,
		length: u64,
		error: *mut *mut glib::GError,
	);

	//=========================================================================
	// ArvGcPropertyNode
	//=========================================================================
	pub fn arv_gc_property_node_get_type() -> GType;
	pub fn arv_gc_property_node_new_access_mode() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_address() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_bit() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_cachable() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_chunk_id() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_command_value() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_constant() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_description() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_display_name() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_display_notation() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_display_precision() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_endianness() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_event_id() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_expression() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_formula() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_formula_from() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_formula_to() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_imposed_access_mode() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_increment() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_is_linear() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_length() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_lsb() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_maximum() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_minimum() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_msb() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_off_value() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_on_value() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_p_address() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_p_command_value() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_p_feature() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_p_increment() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_p_is_available() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_p_is_implemented() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_p_is_locked() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_p_length() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_p_maximum() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_p_minimum() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_p_port() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_p_selected() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_p_value() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_p_value_default() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_p_variable() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_polling_time() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_representation() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_sign() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_slope() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_streamable() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_tooltip() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_unit() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_value() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_value_default() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_new_visibility() -> *mut ArvGcNode;
	pub fn arv_gc_property_node_get_access_mode(
		self_: *mut ArvGcPropertyNode,
		default_value: ArvGcAccessMode,
	) -> ArvGcAccessMode;
	pub fn arv_gc_property_node_get_cachable(
		self_: *mut ArvGcPropertyNode,
		default_value: ArvGcCachable,
	) -> ArvGcCachable;
	pub fn arv_gc_property_node_get_display_notation(
		self_: *mut ArvGcPropertyNode,
		default_value: ArvGcDisplayNotation,
	) -> ArvGcDisplayNotation;
	pub fn arv_gc_property_node_get_display_precision(
		self_: *mut ArvGcPropertyNode,
		default_value: i64,
	) -> i64;
	pub fn arv_gc_property_node_get_double(
		node: *mut ArvGcPropertyNode,
		error: *mut *mut glib::GError,
	) -> c_double;
	pub fn arv_gc_property_node_get_endianness(
		self_: *mut ArvGcPropertyNode,
		default_value: c_uint,
	) -> c_uint;
	pub fn arv_gc_property_node_get_int64(
		node: *mut ArvGcPropertyNode,
		error: *mut *mut glib::GError,
	) -> i64;
	pub fn arv_gc_property_node_get_linked_node(node: *mut ArvGcPropertyNode) -> *mut ArvGcNode;
	pub fn arv_gc_property_node_get_lsb(
		self_: *mut ArvGcPropertyNode,
		default_value: c_uint,
	) -> c_uint;
	pub fn arv_gc_property_node_get_msb(
		self_: *mut ArvGcPropertyNode,
		default_value: c_uint,
	) -> c_uint;
	pub fn arv_gc_property_node_get_name(node: *mut ArvGcPropertyNode) -> *const c_char;
	pub fn arv_gc_property_node_get_node_type(
		node: *mut ArvGcPropertyNode,
	) -> ArvGcPropertyNodeType;
	pub fn arv_gc_property_node_get_representation(
		self_: *mut ArvGcPropertyNode,
		default_value: ArvGcRepresentation,
	) -> ArvGcRepresentation;
	pub fn arv_gc_property_node_get_sign(
		self_: *mut ArvGcPropertyNode,
		default_value: ArvGcSignedness,
	) -> ArvGcSignedness;
	#[cfg(any(feature = "v0_8_8", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_8")))]
	pub fn arv_gc_property_node_get_streamable(
		self_: *mut ArvGcPropertyNode,
		default_value: ArvGcStreamable,
	) -> ArvGcStreamable;
	pub fn arv_gc_property_node_get_string(
		node: *mut ArvGcPropertyNode,
		error: *mut *mut glib::GError,
	) -> *const c_char;
	pub fn arv_gc_property_node_get_visibility(
		self_: *mut ArvGcPropertyNode,
		default_value: ArvGcVisibility,
	) -> ArvGcVisibility;
	pub fn arv_gc_property_node_set_double(
		node: *mut ArvGcPropertyNode,
		v_double: c_double,
		error: *mut *mut glib::GError,
	);
	pub fn arv_gc_property_node_set_int64(
		node: *mut ArvGcPropertyNode,
		v_int64: i64,
		error: *mut *mut glib::GError,
	);
	pub fn arv_gc_property_node_set_string(
		node: *mut ArvGcPropertyNode,
		string: *const c_char,
		error: *mut *mut glib::GError,
	);

	//=========================================================================
	// ArvGcRegisterDescriptionNode
	//=========================================================================
	pub fn arv_gc_register_description_node_get_type() -> GType;
	pub fn arv_gc_register_description_node_new() -> *mut ArvGcNode;
	pub fn arv_gc_register_description_node_check_schema_version(
		node: *mut ArvGcRegisterDescriptionNode,
		required_major: c_uint,
		required_minor: c_uint,
		required_subminor: c_uint,
	) -> gboolean;
	pub fn arv_gc_register_description_node_compare_schema_version(
		node: *mut ArvGcRegisterDescriptionNode,
		major: c_uint,
		minor: c_uint,
		subminor: c_uint,
	) -> c_int;
	pub fn arv_gc_register_description_node_get_major_version(
		node: *mut ArvGcRegisterDescriptionNode,
	) -> c_uint;
	pub fn arv_gc_register_description_node_get_minor_version(
		node: *mut ArvGcRegisterDescriptionNode,
	) -> c_uint;
	pub fn arv_gc_register_description_node_get_model_name(
		node: *mut ArvGcRegisterDescriptionNode,
	) -> *mut c_char;
	pub fn arv_gc_register_description_node_get_schema_major_version(
		node: *mut ArvGcRegisterDescriptionNode,
	) -> c_uint;
	pub fn arv_gc_register_description_node_get_schema_minor_version(
		node: *mut ArvGcRegisterDescriptionNode,
	) -> c_uint;
	pub fn arv_gc_register_description_node_get_schema_subminor_version(
		node: *mut ArvGcRegisterDescriptionNode,
	) -> c_uint;
	pub fn arv_gc_register_description_node_get_subminor_version(
		node: *mut ArvGcRegisterDescriptionNode,
	) -> c_uint;
	pub fn arv_gc_register_description_node_get_vendor_name(
		node: *mut ArvGcRegisterDescriptionNode,
	) -> *mut c_char;

	//=========================================================================
	// ArvGcRegisterNode
	//=========================================================================
	pub fn arv_gc_register_node_get_type() -> GType;
	pub fn arv_gc_register_node_new() -> *mut ArvGcNode;

	//=========================================================================
	// ArvGcStringNode
	//=========================================================================
	pub fn arv_gc_string_node_get_type() -> GType;
	pub fn arv_gc_string_node_new() -> *mut ArvGcNode;

	//=========================================================================
	// ArvGcStringRegNode
	//=========================================================================
	pub fn arv_gc_string_reg_node_get_type() -> GType;
	pub fn arv_gc_string_reg_node_new() -> *mut ArvGcNode;

	//=========================================================================
	// ArvGcStructEntryNode
	//=========================================================================
	pub fn arv_gc_struct_entry_node_get_type() -> GType;
	pub fn arv_gc_struct_entry_node_new() -> *mut ArvGcNode;

	//=========================================================================
	// ArvGcStructRegNode
	//=========================================================================
	pub fn arv_gc_struct_reg_node_get_type() -> GType;
	pub fn arv_gc_struct_reg_node_new() -> *mut ArvGcNode;

	//=========================================================================
	// ArvGcSwissKnife
	//=========================================================================
	pub fn arv_gc_swiss_knife_get_type() -> GType;

	//=========================================================================
	// ArvGcSwissKnifeNode
	//=========================================================================
	pub fn arv_gc_swiss_knife_node_get_type() -> GType;
	pub fn arv_gc_swiss_knife_node_new() -> *mut ArvGcNode;

	//=========================================================================
	// ArvGcValueIndexedNode
	//=========================================================================
	pub fn arv_gc_value_indexed_node_get_type() -> GType;
	pub fn arv_gc_value_indexed_node_new() -> *mut ArvGcNode;
	pub fn arv_gc_value_indexed_node_get_index(
		value_indexed_node: *mut ArvGcValueIndexedNode,
	) -> i64;

	//=========================================================================
	// ArvGvDevice
	//=========================================================================
	pub fn arv_gv_device_get_type() -> GType;
	pub fn arv_gv_device_new(
		interface_address: *mut gio::GInetAddress,
		device_address: *mut gio::GInetAddress,
		error: *mut *mut glib::GError,
	) -> *mut ArvDevice;
	pub fn arv_gv_device_auto_packet_size(
		gv_device: *mut ArvGvDevice,
		error: *mut *mut glib::GError,
	) -> c_uint;
	pub fn arv_gv_device_get_device_address(device: *mut ArvGvDevice) -> *mut gio::GSocketAddress;
	pub fn arv_gv_device_get_interface_address(
		device: *mut ArvGvDevice,
	) -> *mut gio::GSocketAddress;
	pub fn arv_gv_device_get_packet_size(
		gv_device: *mut ArvGvDevice,
		error: *mut *mut glib::GError,
	) -> c_uint;
	pub fn arv_gv_device_get_stream_options(gv_device: *mut ArvGvDevice) -> ArvGvStreamOption;
	pub fn arv_gv_device_get_timestamp_tick_frequency(
		gv_device: *mut ArvGvDevice,
		error: *mut *mut glib::GError,
	) -> u64;
	pub fn arv_gv_device_is_controller(gv_device: *mut ArvGvDevice) -> gboolean;
	#[cfg(any(feature = "v0_8_3", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_3")))]
	pub fn arv_gv_device_leave_control(
		gv_device: *mut ArvGvDevice,
		error: *mut *mut glib::GError,
	) -> gboolean;
	pub fn arv_gv_device_set_packet_size(
		gv_device: *mut ArvGvDevice,
		packet_size: c_int,
		error: *mut *mut glib::GError,
	);
	#[cfg(any(feature = "v0_8_3", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_3")))]
	pub fn arv_gv_device_set_packet_size_adjustment(
		gv_device: *mut ArvGvDevice,
		adjustment: ArvGvPacketSizeAdjustment,
	);
	pub fn arv_gv_device_set_stream_options(
		gv_device: *mut ArvGvDevice,
		options: ArvGvStreamOption,
	);
	#[cfg(any(feature = "v0_8_3", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_3")))]
	pub fn arv_gv_device_take_control(
		gv_device: *mut ArvGvDevice,
		error: *mut *mut glib::GError,
	) -> gboolean;

	//=========================================================================
	// ArvGvFakeCamera
	//=========================================================================
	pub fn arv_gv_fake_camera_get_type() -> GType;
	pub fn arv_gv_fake_camera_new(
		interface_name: *const c_char,
		serial_number: *const c_char,
	) -> *mut ArvGvFakeCamera;
	pub fn arv_gv_fake_camera_new_full(
		interface_name: *const c_char,
		serial_number: *const c_char,
		genicam_filename: *const c_char,
	) -> *mut ArvGvFakeCamera;
	pub fn arv_gv_fake_camera_get_fake_camera(
		gv_fake_camera: *mut ArvGvFakeCamera,
	) -> *mut ArvFakeCamera;
	pub fn arv_gv_fake_camera_is_running(gv_fake_camera: *mut ArvGvFakeCamera) -> gboolean;

	//=========================================================================
	// ArvGvInterface
	//=========================================================================
	pub fn arv_gv_interface_get_type() -> GType;
	pub fn arv_gv_interface_get_instance() -> *mut ArvInterface;

	//=========================================================================
	// ArvGvStream
	//=========================================================================
	pub fn arv_gv_stream_get_type() -> GType;
	pub fn arv_gv_stream_get_port(gv_stream: *mut ArvGvStream) -> u16;
	pub fn arv_gv_stream_get_statistics(
		gv_stream: *mut ArvGvStream,
		n_resent_packets: *mut u64,
		n_missing_packets: *mut u64,
	);

	//=========================================================================
	// ArvInterface
	//=========================================================================
	pub fn arv_interface_get_type() -> GType;
	pub fn arv_interface_get_device_address(
		interface: *mut ArvInterface,
		index: c_uint,
	) -> *const c_char;
	pub fn arv_interface_get_device_id(
		interface: *mut ArvInterface,
		index: c_uint,
	) -> *const c_char;
	pub fn arv_interface_get_device_model(
		interface: *mut ArvInterface,
		index: c_uint,
	) -> *const c_char;
	pub fn arv_interface_get_device_physical_id(
		interface: *mut ArvInterface,
		index: c_uint,
	) -> *const c_char;
	pub fn arv_interface_get_device_protocol(
		interface: *mut ArvInterface,
		index: c_uint,
	) -> *const c_char;
	pub fn arv_interface_get_device_serial_nbr(
		interface: *mut ArvInterface,
		index: c_uint,
	) -> *const c_char;
	pub fn arv_interface_get_device_vendor(
		interface: *mut ArvInterface,
		index: c_uint,
	) -> *const c_char;
	pub fn arv_interface_get_n_devices(interface: *mut ArvInterface) -> c_uint;
	pub fn arv_interface_open_device(
		interface: *mut ArvInterface,
		device_id: *const c_char,
		error: *mut *mut glib::GError,
	) -> *mut ArvDevice;
	pub fn arv_interface_update_device_list(interface: *mut ArvInterface);

	//=========================================================================
	// ArvStream
	//=========================================================================
	pub fn arv_stream_get_type() -> GType;
	pub fn arv_stream_get_emit_signals(stream: *mut ArvStream) -> gboolean;
	#[cfg(any(feature = "v0_8_11", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_11")))]
	pub fn arv_stream_get_info_double(stream: *mut ArvStream, id: c_uint) -> c_double;
	#[cfg(any(feature = "v0_8_11", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_11")))]
	pub fn arv_stream_get_info_double_by_name(
		stream: *mut ArvStream,
		name: *const c_char,
	) -> c_double;
	#[cfg(any(feature = "v0_8_11", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_11")))]
	pub fn arv_stream_get_info_name(stream: *mut ArvStream, id: c_uint) -> *const c_char;
	#[cfg(any(feature = "v0_8_11", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_11")))]
	pub fn arv_stream_get_info_type(stream: *mut ArvStream, id: c_uint) -> GType;
	#[cfg(any(feature = "v0_8_11", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_11")))]
	pub fn arv_stream_get_info_uint64(stream: *mut ArvStream, id: c_uint) -> u64;
	#[cfg(any(feature = "v0_8_11", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_11")))]
	pub fn arv_stream_get_info_uint64_by_name(stream: *mut ArvStream, name: *const c_char) -> u64;
	pub fn arv_stream_get_n_buffers(
		stream: *mut ArvStream,
		n_input_buffers: *mut c_int,
		n_output_buffers: *mut c_int,
	);
	#[cfg(any(feature = "v0_8_11", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_11")))]
	pub fn arv_stream_get_n_infos(stream: *mut ArvStream) -> c_uint;
	pub fn arv_stream_get_statistics(
		stream: *mut ArvStream,
		n_completed_buffers: *mut u64,
		n_failures: *mut u64,
		n_underruns: *mut u64,
	);
	pub fn arv_stream_pop_buffer(stream: *mut ArvStream) -> *mut ArvBuffer;
	pub fn arv_stream_push_buffer(stream: *mut ArvStream, buffer: *mut ArvBuffer);
	pub fn arv_stream_set_emit_signals(stream: *mut ArvStream, emit_signals: gboolean);
	pub fn arv_stream_start_thread(stream: *mut ArvStream);
	pub fn arv_stream_stop_thread(stream: *mut ArvStream, delete_buffers: gboolean) -> c_uint;
	pub fn arv_stream_timeout_pop_buffer(stream: *mut ArvStream, timeout: u64) -> *mut ArvBuffer;
	pub fn arv_stream_try_pop_buffer(stream: *mut ArvStream) -> *mut ArvBuffer;

	//=========================================================================
	// ArvUvDevice
	//=========================================================================
	pub fn arv_uv_device_get_type() -> GType;
	pub fn arv_uv_device_new(
		vendor: *const c_char,
		product: *const c_char,
		serial_number: *const c_char,
		error: *mut *mut glib::GError,
	) -> *mut ArvDevice;

	//=========================================================================
	// ArvUvInterface
	//=========================================================================
	pub fn arv_uv_interface_get_type() -> GType;
	pub fn arv_uv_interface_get_instance() -> *mut ArvInterface;

	//=========================================================================
	// ArvUvStream
	//=========================================================================
	pub fn arv_uv_stream_get_type() -> GType;

	//=========================================================================
	// ArvXmlSchema
	//=========================================================================
	pub fn arv_xml_schema_get_type() -> GType;
	pub fn arv_xml_schema_new_from_file(file: *mut gio::GFile) -> *mut ArvXmlSchema;
	pub fn arv_xml_schema_new_from_path(path: *const c_char) -> *mut ArvXmlSchema;
	pub fn arv_xml_schema_validate(
		schema: *mut ArvXmlSchema,
		xml: *mut c_void,
		size: size_t,
		line: *mut c_int,
		column: *mut c_int,
		error: *mut *mut glib::GError,
	) -> gboolean;

	//=========================================================================
	// ArvGcFloat
	//=========================================================================
	pub fn arv_gc_float_get_type() -> GType;
	pub fn arv_gc_float_get_display_notation(gc_float: *mut ArvGcFloat) -> ArvGcDisplayNotation;
	pub fn arv_gc_float_get_display_precision(gc_float: *mut ArvGcFloat) -> i64;
	pub fn arv_gc_float_get_inc(
		gc_float: *mut ArvGcFloat,
		error: *mut *mut glib::GError,
	) -> c_double;
	pub fn arv_gc_float_get_max(
		gc_float: *mut ArvGcFloat,
		error: *mut *mut glib::GError,
	) -> c_double;
	pub fn arv_gc_float_get_min(
		gc_float: *mut ArvGcFloat,
		error: *mut *mut glib::GError,
	) -> c_double;
	pub fn arv_gc_float_get_representation(gc_float: *mut ArvGcFloat) -> ArvGcRepresentation;
	pub fn arv_gc_float_get_unit(gc_float: *mut ArvGcFloat) -> *const c_char;
	pub fn arv_gc_float_get_value(
		gc_float: *mut ArvGcFloat,
		error: *mut *mut glib::GError,
	) -> c_double;
	pub fn arv_gc_float_impose_max(
		gc_float: *mut ArvGcFloat,
		maximum: c_double,
		error: *mut *mut glib::GError,
	);
	pub fn arv_gc_float_impose_min(
		gc_float: *mut ArvGcFloat,
		minimum: c_double,
		error: *mut *mut glib::GError,
	);
	pub fn arv_gc_float_set_value(
		gc_float: *mut ArvGcFloat,
		value: c_double,
		error: *mut *mut glib::GError,
	);

	//=========================================================================
	// ArvGcInteger
	//=========================================================================
	pub fn arv_gc_integer_get_type() -> GType;
	pub fn arv_gc_integer_get_inc(
		gc_integer: *mut ArvGcInteger,
		error: *mut *mut glib::GError,
	) -> i64;
	pub fn arv_gc_integer_get_max(
		gc_integer: *mut ArvGcInteger,
		error: *mut *mut glib::GError,
	) -> i64;
	pub fn arv_gc_integer_get_min(
		gc_integer: *mut ArvGcInteger,
		error: *mut *mut glib::GError,
	) -> i64;
	pub fn arv_gc_integer_get_representation(gc_integer: *mut ArvGcInteger) -> ArvGcRepresentation;
	pub fn arv_gc_integer_get_unit(gc_integer: *mut ArvGcInteger) -> *const c_char;
	pub fn arv_gc_integer_get_value(
		gc_integer: *mut ArvGcInteger,
		error: *mut *mut glib::GError,
	) -> i64;
	pub fn arv_gc_integer_impose_max(
		gc_integer: *mut ArvGcInteger,
		maximum: i64,
		error: *mut *mut glib::GError,
	);
	pub fn arv_gc_integer_impose_min(
		gc_integer: *mut ArvGcInteger,
		minimum: i64,
		error: *mut *mut glib::GError,
	);
	pub fn arv_gc_integer_set_value(
		gc_integer: *mut ArvGcInteger,
		value: i64,
		error: *mut *mut glib::GError,
	);

	//=========================================================================
	// ArvGcRegister
	//=========================================================================
	pub fn arv_gc_register_get_type() -> GType;
	pub fn arv_gc_register_get(
		gc_register: *mut ArvGcRegister,
		buffer: *mut c_void,
		length: u64,
		error: *mut *mut glib::GError,
	);
	pub fn arv_gc_register_get_address(
		gc_register: *mut ArvGcRegister,
		error: *mut *mut glib::GError,
	) -> u64;
	pub fn arv_gc_register_get_length(
		gc_register: *mut ArvGcRegister,
		error: *mut *mut glib::GError,
	) -> u64;
	pub fn arv_gc_register_set(
		gc_register: *mut ArvGcRegister,
		buffer: *mut c_void,
		length: u64,
		error: *mut *mut glib::GError,
	);

	//=========================================================================
	// ArvGcSelector
	//=========================================================================
	pub fn arv_gc_selector_get_type() -> GType;
	pub fn arv_gc_selector_get_selected_features(
		gc_selector: *mut ArvGcSelector,
	) -> *const glib::GSList;
	pub fn arv_gc_selector_is_selector(gc_selector: *mut ArvGcSelector) -> gboolean;

	//=========================================================================
	// ArvGcString
	//=========================================================================
	pub fn arv_gc_string_get_type() -> GType;
	pub fn arv_gc_string_get_max_length(
		gc_string: *mut ArvGcString,
		error: *mut *mut glib::GError,
	) -> i64;
	pub fn arv_gc_string_get_value(
		gc_string: *mut ArvGcString,
		error: *mut *mut glib::GError,
	) -> *const c_char;
	pub fn arv_gc_string_set_value(
		gc_string: *mut ArvGcString,
		value: *const c_char,
		error: *mut *mut glib::GError,
	);

	//=========================================================================
	// Other functions
	//=========================================================================
	pub fn arv_debug_enable(category_selection: *const c_char) -> gboolean;
	pub fn arv_disable_interface(interface_id: *const c_char);
	pub fn arv_dom_implementation_add_document_type(
		qualified_name: *const c_char,
		document_type: GType,
	);
	pub fn arv_dom_implementation_cleanup();
	pub fn arv_dom_implementation_create_document(
		namespace_uri: *const c_char,
		qualified_name: *const c_char,
	) -> *mut ArvDomDocument;
	pub fn arv_enable_interface(interface_id: *const c_char);
	pub fn arv_get_device_address(index: c_uint) -> *const c_char;
	pub fn arv_get_device_id(index: c_uint) -> *const c_char;
	pub fn arv_get_device_model(index: c_uint) -> *const c_char;
	pub fn arv_get_device_physical_id(index: c_uint) -> *const c_char;
	pub fn arv_get_device_protocol(index: c_uint) -> *const c_char;
	pub fn arv_get_device_serial_nbr(index: c_uint) -> *const c_char;
	pub fn arv_get_device_vendor(index: c_uint) -> *const c_char;
	pub fn arv_get_interface_id(index: c_uint) -> *const c_char;
	pub fn arv_get_n_devices() -> c_uint;
	pub fn arv_get_n_interfaces() -> c_uint;
	pub fn arv_make_thread_high_priority(nice_level: c_int) -> gboolean;
	pub fn arv_make_thread_realtime(priority: c_int) -> gboolean;
	pub fn arv_open_device(
		device_id: *const c_char,
		error: *mut *mut glib::GError,
	) -> *mut ArvDevice;
	pub fn arv_set_fake_camera_genicam_filename(filename: *const c_char);
	pub fn arv_shutdown();
	pub fn arv_update_device_list();

}
